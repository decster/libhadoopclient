// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdfs.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "hdfs.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace hadoop {
namespace hdfs {

namespace {

const ::google::protobuf::Descriptor* ExtendedBlockProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExtendedBlockProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DatanodeIDProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DatanodeIDProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DatanodeInfosProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DatanodeInfosProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DatanodeInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DatanodeInfoProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DatanodeInfoProto_AdminState_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ContentSummaryProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContentSummaryProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* CorruptFileBlocksProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CorruptFileBlocksProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* FsPermissionProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FsPermissionProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* StorageUuidsProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StorageUuidsProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* LocatedBlockProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LocatedBlockProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataEncryptionKeyProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataEncryptionKeyProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* LocatedBlocksProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LocatedBlocksProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* HdfsFileStatusProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HdfsFileStatusProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* HdfsFileStatusProto_FileType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FsServerDefaultsProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FsServerDefaultsProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DirectoryListingProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DirectoryListingProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* SnapshottableDirectoryStatusProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SnapshottableDirectoryStatusProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* SnapshottableDirectoryListingProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SnapshottableDirectoryListingProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* SnapshotDiffReportEntryProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SnapshotDiffReportEntryProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* SnapshotDiffReportProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SnapshotDiffReportProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* StorageInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StorageInfoProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* NamenodeRegistrationProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NamenodeRegistrationProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* NamenodeRegistrationProto_NamenodeRoleProto_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CheckpointSignatureProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckpointSignatureProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* NamenodeCommandProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NamenodeCommandProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* NamenodeCommandProto_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CheckpointCommandProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckpointCommandProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlockProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlockProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlockWithLocationsProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlockWithLocationsProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlocksWithLocationsProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlocksWithLocationsProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* RemoteEditLogProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RemoteEditLogProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* RemoteEditLogManifestProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RemoteEditLogManifestProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* NamespaceInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NamespaceInfoProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* BlockKeyProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BlockKeyProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExportedBlockKeysProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExportedBlockKeysProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* RecoveringBlockProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RecoveringBlockProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* VersionRequestProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VersionRequestProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* VersionResponseProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VersionResponseProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* SnapshotInfoProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SnapshotInfoProto_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* StorageTypeProto_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ChecksumTypeProto_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ReplicaStateProto_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_hdfs_2eproto() {
  protobuf_AddDesc_hdfs_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "hdfs.proto");
  GOOGLE_CHECK(file != NULL);
  ExtendedBlockProto_descriptor_ = file->message_type(0);
  static const int ExtendedBlockProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, poolid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, blockid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, generationstamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, numbytes_),
  };
  ExtendedBlockProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExtendedBlockProto_descriptor_,
      ExtendedBlockProto::default_instance_,
      ExtendedBlockProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExtendedBlockProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExtendedBlockProto));
  DatanodeIDProto_descriptor_ = file->message_type(1);
  static const int DatanodeIDProto_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, ipaddr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, datanodeuuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, xferport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, infoport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, ipcport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, infosecureport_),
  };
  DatanodeIDProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DatanodeIDProto_descriptor_,
      DatanodeIDProto::default_instance_,
      DatanodeIDProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeIDProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DatanodeIDProto));
  DatanodeInfosProto_descriptor_ = file->message_type(2);
  static const int DatanodeInfosProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfosProto, datanodes_),
  };
  DatanodeInfosProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DatanodeInfosProto_descriptor_,
      DatanodeInfosProto::default_instance_,
      DatanodeInfosProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfosProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfosProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DatanodeInfosProto));
  DatanodeInfoProto_descriptor_ = file->message_type(3);
  static const int DatanodeInfoProto_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, capacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, dfsused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, remaining_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, blockpoolused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, lastupdate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, xceivercount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, adminstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, cachecapacity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, cacheused_),
  };
  DatanodeInfoProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DatanodeInfoProto_descriptor_,
      DatanodeInfoProto::default_instance_,
      DatanodeInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DatanodeInfoProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DatanodeInfoProto));
  DatanodeInfoProto_AdminState_descriptor_ = DatanodeInfoProto_descriptor_->enum_type(0);
  ContentSummaryProto_descriptor_ = file->message_type(4);
  static const int ContentSummaryProto_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContentSummaryProto, length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContentSummaryProto, filecount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContentSummaryProto, directorycount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContentSummaryProto, quota_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContentSummaryProto, spaceconsumed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContentSummaryProto, spacequota_),
  };
  ContentSummaryProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ContentSummaryProto_descriptor_,
      ContentSummaryProto::default_instance_,
      ContentSummaryProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContentSummaryProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContentSummaryProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ContentSummaryProto));
  CorruptFileBlocksProto_descriptor_ = file->message_type(5);
  static const int CorruptFileBlocksProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorruptFileBlocksProto, files_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorruptFileBlocksProto, cookie_),
  };
  CorruptFileBlocksProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CorruptFileBlocksProto_descriptor_,
      CorruptFileBlocksProto::default_instance_,
      CorruptFileBlocksProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorruptFileBlocksProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CorruptFileBlocksProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CorruptFileBlocksProto));
  FsPermissionProto_descriptor_ = file->message_type(6);
  static const int FsPermissionProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsPermissionProto, perm_),
  };
  FsPermissionProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FsPermissionProto_descriptor_,
      FsPermissionProto::default_instance_,
      FsPermissionProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsPermissionProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsPermissionProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FsPermissionProto));
  StorageUuidsProto_descriptor_ = file->message_type(7);
  static const int StorageUuidsProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageUuidsProto, storageuuids_),
  };
  StorageUuidsProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StorageUuidsProto_descriptor_,
      StorageUuidsProto::default_instance_,
      StorageUuidsProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageUuidsProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageUuidsProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StorageUuidsProto));
  LocatedBlockProto_descriptor_ = file->message_type(8);
  static const int LocatedBlockProto_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, b_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, locs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, corrupt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, blocktoken_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, iscached_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, storagetypes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, storageids_),
  };
  LocatedBlockProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LocatedBlockProto_descriptor_,
      LocatedBlockProto::default_instance_,
      LocatedBlockProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlockProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LocatedBlockProto));
  DataEncryptionKeyProto_descriptor_ = file->message_type(9);
  static const int DataEncryptionKeyProto_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEncryptionKeyProto, keyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEncryptionKeyProto, blockpoolid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEncryptionKeyProto, nonce_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEncryptionKeyProto, encryptionkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEncryptionKeyProto, expirydate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEncryptionKeyProto, encryptionalgorithm_),
  };
  DataEncryptionKeyProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataEncryptionKeyProto_descriptor_,
      DataEncryptionKeyProto::default_instance_,
      DataEncryptionKeyProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEncryptionKeyProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataEncryptionKeyProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataEncryptionKeyProto));
  LocatedBlocksProto_descriptor_ = file->message_type(10);
  static const int LocatedBlocksProto_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, filelength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, blocks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, underconstruction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, lastblock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, islastblockcomplete_),
  };
  LocatedBlocksProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LocatedBlocksProto_descriptor_,
      LocatedBlocksProto::default_instance_,
      LocatedBlocksProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LocatedBlocksProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LocatedBlocksProto));
  HdfsFileStatusProto_descriptor_ = file->message_type(11);
  static const int HdfsFileStatusProto_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, filetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, permission_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, owner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, group_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, modification_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, access_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, symlink_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, block_replication_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, blocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, locations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, fileid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, childrennum_),
  };
  HdfsFileStatusProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HdfsFileStatusProto_descriptor_,
      HdfsFileStatusProto::default_instance_,
      HdfsFileStatusProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HdfsFileStatusProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HdfsFileStatusProto));
  HdfsFileStatusProto_FileType_descriptor_ = HdfsFileStatusProto_descriptor_->enum_type(0);
  FsServerDefaultsProto_descriptor_ = file->message_type(12);
  static const int FsServerDefaultsProto_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, blocksize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, bytesperchecksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, writepacketsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, replication_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, filebuffersize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, encryptdatatransfer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, trashinterval_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, checksumtype_),
  };
  FsServerDefaultsProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FsServerDefaultsProto_descriptor_,
      FsServerDefaultsProto::default_instance_,
      FsServerDefaultsProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FsServerDefaultsProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FsServerDefaultsProto));
  DirectoryListingProto_descriptor_ = file->message_type(13);
  static const int DirectoryListingProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirectoryListingProto, partiallisting_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirectoryListingProto, remainingentries_),
  };
  DirectoryListingProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DirectoryListingProto_descriptor_,
      DirectoryListingProto::default_instance_,
      DirectoryListingProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirectoryListingProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirectoryListingProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DirectoryListingProto));
  SnapshottableDirectoryStatusProto_descriptor_ = file->message_type(14);
  static const int SnapshottableDirectoryStatusProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryStatusProto, dirstatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryStatusProto, snapshot_quota_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryStatusProto, snapshot_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryStatusProto, parent_fullpath_),
  };
  SnapshottableDirectoryStatusProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SnapshottableDirectoryStatusProto_descriptor_,
      SnapshottableDirectoryStatusProto::default_instance_,
      SnapshottableDirectoryStatusProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryStatusProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryStatusProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SnapshottableDirectoryStatusProto));
  SnapshottableDirectoryListingProto_descriptor_ = file->message_type(15);
  static const int SnapshottableDirectoryListingProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryListingProto, snapshottabledirlisting_),
  };
  SnapshottableDirectoryListingProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SnapshottableDirectoryListingProto_descriptor_,
      SnapshottableDirectoryListingProto::default_instance_,
      SnapshottableDirectoryListingProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryListingProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshottableDirectoryListingProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SnapshottableDirectoryListingProto));
  SnapshotDiffReportEntryProto_descriptor_ = file->message_type(16);
  static const int SnapshotDiffReportEntryProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportEntryProto, fullpath_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportEntryProto, modificationlabel_),
  };
  SnapshotDiffReportEntryProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SnapshotDiffReportEntryProto_descriptor_,
      SnapshotDiffReportEntryProto::default_instance_,
      SnapshotDiffReportEntryProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportEntryProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportEntryProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SnapshotDiffReportEntryProto));
  SnapshotDiffReportProto_descriptor_ = file->message_type(17);
  static const int SnapshotDiffReportProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportProto, snapshotroot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportProto, fromsnapshot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportProto, tosnapshot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportProto, diffreportentries_),
  };
  SnapshotDiffReportProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SnapshotDiffReportProto_descriptor_,
      SnapshotDiffReportProto::default_instance_,
      SnapshotDiffReportProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotDiffReportProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SnapshotDiffReportProto));
  StorageInfoProto_descriptor_ = file->message_type(18);
  static const int StorageInfoProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, layoutversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, namespceid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, clusterid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, ctime_),
  };
  StorageInfoProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StorageInfoProto_descriptor_,
      StorageInfoProto::default_instance_,
      StorageInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StorageInfoProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StorageInfoProto));
  NamenodeRegistrationProto_descriptor_ = file->message_type(19);
  static const int NamenodeRegistrationProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeRegistrationProto, rpcaddress_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeRegistrationProto, httpaddress_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeRegistrationProto, storageinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeRegistrationProto, role_),
  };
  NamenodeRegistrationProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NamenodeRegistrationProto_descriptor_,
      NamenodeRegistrationProto::default_instance_,
      NamenodeRegistrationProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeRegistrationProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeRegistrationProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NamenodeRegistrationProto));
  NamenodeRegistrationProto_NamenodeRoleProto_descriptor_ = NamenodeRegistrationProto_descriptor_->enum_type(0);
  CheckpointSignatureProto_descriptor_ = file->message_type(20);
  static const int CheckpointSignatureProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointSignatureProto, blockpoolid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointSignatureProto, mostrecentcheckpointtxid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointSignatureProto, cursegmenttxid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointSignatureProto, storageinfo_),
  };
  CheckpointSignatureProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckpointSignatureProto_descriptor_,
      CheckpointSignatureProto::default_instance_,
      CheckpointSignatureProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointSignatureProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointSignatureProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckpointSignatureProto));
  NamenodeCommandProto_descriptor_ = file->message_type(21);
  static const int NamenodeCommandProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeCommandProto, action_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeCommandProto, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeCommandProto, checkpointcmd_),
  };
  NamenodeCommandProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NamenodeCommandProto_descriptor_,
      NamenodeCommandProto::default_instance_,
      NamenodeCommandProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeCommandProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamenodeCommandProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NamenodeCommandProto));
  NamenodeCommandProto_Type_descriptor_ = NamenodeCommandProto_descriptor_->enum_type(0);
  CheckpointCommandProto_descriptor_ = file->message_type(22);
  static const int CheckpointCommandProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointCommandProto, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointCommandProto, needtoreturnimage_),
  };
  CheckpointCommandProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckpointCommandProto_descriptor_,
      CheckpointCommandProto::default_instance_,
      CheckpointCommandProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointCommandProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckpointCommandProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckpointCommandProto));
  BlockProto_descriptor_ = file->message_type(23);
  static const int BlockProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockProto, blockid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockProto, genstamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockProto, numbytes_),
  };
  BlockProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlockProto_descriptor_,
      BlockProto::default_instance_,
      BlockProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlockProto));
  BlockWithLocationsProto_descriptor_ = file->message_type(24);
  static const int BlockWithLocationsProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockWithLocationsProto, block_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockWithLocationsProto, datanodeuuids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockWithLocationsProto, storageuuids_),
  };
  BlockWithLocationsProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlockWithLocationsProto_descriptor_,
      BlockWithLocationsProto::default_instance_,
      BlockWithLocationsProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockWithLocationsProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockWithLocationsProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlockWithLocationsProto));
  BlocksWithLocationsProto_descriptor_ = file->message_type(25);
  static const int BlocksWithLocationsProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlocksWithLocationsProto, blocks_),
  };
  BlocksWithLocationsProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlocksWithLocationsProto_descriptor_,
      BlocksWithLocationsProto::default_instance_,
      BlocksWithLocationsProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlocksWithLocationsProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlocksWithLocationsProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlocksWithLocationsProto));
  RemoteEditLogProto_descriptor_ = file->message_type(26);
  static const int RemoteEditLogProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteEditLogProto, starttxid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteEditLogProto, endtxid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteEditLogProto, isinprogress_),
  };
  RemoteEditLogProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RemoteEditLogProto_descriptor_,
      RemoteEditLogProto::default_instance_,
      RemoteEditLogProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteEditLogProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteEditLogProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RemoteEditLogProto));
  RemoteEditLogManifestProto_descriptor_ = file->message_type(27);
  static const int RemoteEditLogManifestProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteEditLogManifestProto, logs_),
  };
  RemoteEditLogManifestProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RemoteEditLogManifestProto_descriptor_,
      RemoteEditLogManifestProto::default_instance_,
      RemoteEditLogManifestProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteEditLogManifestProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteEditLogManifestProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RemoteEditLogManifestProto));
  NamespaceInfoProto_descriptor_ = file->message_type(28);
  static const int NamespaceInfoProto_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespaceInfoProto, buildversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespaceInfoProto, unused_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespaceInfoProto, blockpoolid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespaceInfoProto, storageinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespaceInfoProto, softwareversion_),
  };
  NamespaceInfoProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NamespaceInfoProto_descriptor_,
      NamespaceInfoProto::default_instance_,
      NamespaceInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespaceInfoProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NamespaceInfoProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NamespaceInfoProto));
  BlockKeyProto_descriptor_ = file->message_type(29);
  static const int BlockKeyProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, keyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, expirydate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, keybytes_),
  };
  BlockKeyProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BlockKeyProto_descriptor_,
      BlockKeyProto::default_instance_,
      BlockKeyProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BlockKeyProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BlockKeyProto));
  ExportedBlockKeysProto_descriptor_ = file->message_type(30);
  static const int ExportedBlockKeysProto_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, isblocktokenenabled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, keyupdateinterval_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, tokenlifetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, currentkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, allkeys_),
  };
  ExportedBlockKeysProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExportedBlockKeysProto_descriptor_,
      ExportedBlockKeysProto::default_instance_,
      ExportedBlockKeysProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExportedBlockKeysProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExportedBlockKeysProto));
  RecoveringBlockProto_descriptor_ = file->message_type(31);
  static const int RecoveringBlockProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveringBlockProto, newgenstamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveringBlockProto, block_),
  };
  RecoveringBlockProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RecoveringBlockProto_descriptor_,
      RecoveringBlockProto::default_instance_,
      RecoveringBlockProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveringBlockProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveringBlockProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RecoveringBlockProto));
  VersionRequestProto_descriptor_ = file->message_type(32);
  static const int VersionRequestProto_offsets_[1] = {
  };
  VersionRequestProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VersionRequestProto_descriptor_,
      VersionRequestProto::default_instance_,
      VersionRequestProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionRequestProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionRequestProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VersionRequestProto));
  VersionResponseProto_descriptor_ = file->message_type(33);
  static const int VersionResponseProto_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionResponseProto, info_),
  };
  VersionResponseProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VersionResponseProto_descriptor_,
      VersionResponseProto::default_instance_,
      VersionResponseProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionResponseProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionResponseProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VersionResponseProto));
  SnapshotInfoProto_descriptor_ = file->message_type(34);
  static const int SnapshotInfoProto_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotInfoProto, snapshotname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotInfoProto, snapshotroot_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotInfoProto, permission_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotInfoProto, owner_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotInfoProto, group_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotInfoProto, createtime_),
  };
  SnapshotInfoProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SnapshotInfoProto_descriptor_,
      SnapshotInfoProto::default_instance_,
      SnapshotInfoProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotInfoProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SnapshotInfoProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SnapshotInfoProto));
  StorageTypeProto_descriptor_ = file->enum_type(0);
  ChecksumTypeProto_descriptor_ = file->enum_type(1);
  ReplicaStateProto_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_hdfs_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExtendedBlockProto_descriptor_, &ExtendedBlockProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DatanodeIDProto_descriptor_, &DatanodeIDProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DatanodeInfosProto_descriptor_, &DatanodeInfosProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DatanodeInfoProto_descriptor_, &DatanodeInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ContentSummaryProto_descriptor_, &ContentSummaryProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CorruptFileBlocksProto_descriptor_, &CorruptFileBlocksProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FsPermissionProto_descriptor_, &FsPermissionProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StorageUuidsProto_descriptor_, &StorageUuidsProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LocatedBlockProto_descriptor_, &LocatedBlockProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataEncryptionKeyProto_descriptor_, &DataEncryptionKeyProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LocatedBlocksProto_descriptor_, &LocatedBlocksProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HdfsFileStatusProto_descriptor_, &HdfsFileStatusProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FsServerDefaultsProto_descriptor_, &FsServerDefaultsProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DirectoryListingProto_descriptor_, &DirectoryListingProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SnapshottableDirectoryStatusProto_descriptor_, &SnapshottableDirectoryStatusProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SnapshottableDirectoryListingProto_descriptor_, &SnapshottableDirectoryListingProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SnapshotDiffReportEntryProto_descriptor_, &SnapshotDiffReportEntryProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SnapshotDiffReportProto_descriptor_, &SnapshotDiffReportProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StorageInfoProto_descriptor_, &StorageInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NamenodeRegistrationProto_descriptor_, &NamenodeRegistrationProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckpointSignatureProto_descriptor_, &CheckpointSignatureProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NamenodeCommandProto_descriptor_, &NamenodeCommandProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckpointCommandProto_descriptor_, &CheckpointCommandProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlockProto_descriptor_, &BlockProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlockWithLocationsProto_descriptor_, &BlockWithLocationsProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlocksWithLocationsProto_descriptor_, &BlocksWithLocationsProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RemoteEditLogProto_descriptor_, &RemoteEditLogProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RemoteEditLogManifestProto_descriptor_, &RemoteEditLogManifestProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NamespaceInfoProto_descriptor_, &NamespaceInfoProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BlockKeyProto_descriptor_, &BlockKeyProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExportedBlockKeysProto_descriptor_, &ExportedBlockKeysProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RecoveringBlockProto_descriptor_, &RecoveringBlockProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VersionRequestProto_descriptor_, &VersionRequestProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VersionResponseProto_descriptor_, &VersionResponseProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SnapshotInfoProto_descriptor_, &SnapshotInfoProto::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_hdfs_2eproto() {
  delete ExtendedBlockProto::default_instance_;
  delete ExtendedBlockProto_reflection_;
  delete DatanodeIDProto::default_instance_;
  delete DatanodeIDProto_reflection_;
  delete DatanodeInfosProto::default_instance_;
  delete DatanodeInfosProto_reflection_;
  delete DatanodeInfoProto::default_instance_;
  delete DatanodeInfoProto_reflection_;
  delete ContentSummaryProto::default_instance_;
  delete ContentSummaryProto_reflection_;
  delete CorruptFileBlocksProto::default_instance_;
  delete CorruptFileBlocksProto_reflection_;
  delete FsPermissionProto::default_instance_;
  delete FsPermissionProto_reflection_;
  delete StorageUuidsProto::default_instance_;
  delete StorageUuidsProto_reflection_;
  delete LocatedBlockProto::default_instance_;
  delete LocatedBlockProto_reflection_;
  delete DataEncryptionKeyProto::default_instance_;
  delete DataEncryptionKeyProto_reflection_;
  delete LocatedBlocksProto::default_instance_;
  delete LocatedBlocksProto_reflection_;
  delete HdfsFileStatusProto::default_instance_;
  delete HdfsFileStatusProto_reflection_;
  delete FsServerDefaultsProto::default_instance_;
  delete FsServerDefaultsProto_reflection_;
  delete DirectoryListingProto::default_instance_;
  delete DirectoryListingProto_reflection_;
  delete SnapshottableDirectoryStatusProto::default_instance_;
  delete SnapshottableDirectoryStatusProto_reflection_;
  delete SnapshottableDirectoryListingProto::default_instance_;
  delete SnapshottableDirectoryListingProto_reflection_;
  delete SnapshotDiffReportEntryProto::default_instance_;
  delete SnapshotDiffReportEntryProto_reflection_;
  delete SnapshotDiffReportProto::default_instance_;
  delete SnapshotDiffReportProto_reflection_;
  delete StorageInfoProto::default_instance_;
  delete StorageInfoProto_reflection_;
  delete NamenodeRegistrationProto::default_instance_;
  delete NamenodeRegistrationProto_reflection_;
  delete CheckpointSignatureProto::default_instance_;
  delete CheckpointSignatureProto_reflection_;
  delete NamenodeCommandProto::default_instance_;
  delete NamenodeCommandProto_reflection_;
  delete CheckpointCommandProto::default_instance_;
  delete CheckpointCommandProto_reflection_;
  delete BlockProto::default_instance_;
  delete BlockProto_reflection_;
  delete BlockWithLocationsProto::default_instance_;
  delete BlockWithLocationsProto_reflection_;
  delete BlocksWithLocationsProto::default_instance_;
  delete BlocksWithLocationsProto_reflection_;
  delete RemoteEditLogProto::default_instance_;
  delete RemoteEditLogProto_reflection_;
  delete RemoteEditLogManifestProto::default_instance_;
  delete RemoteEditLogManifestProto_reflection_;
  delete NamespaceInfoProto::default_instance_;
  delete NamespaceInfoProto_reflection_;
  delete BlockKeyProto::default_instance_;
  delete BlockKeyProto_reflection_;
  delete ExportedBlockKeysProto::default_instance_;
  delete ExportedBlockKeysProto_reflection_;
  delete RecoveringBlockProto::default_instance_;
  delete RecoveringBlockProto_reflection_;
  delete VersionRequestProto::default_instance_;
  delete VersionRequestProto_reflection_;
  delete VersionResponseProto::default_instance_;
  delete VersionResponseProto_reflection_;
  delete SnapshotInfoProto::default_instance_;
  delete SnapshotInfoProto_reflection_;
}

void protobuf_AddDesc_hdfs_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::hadoop::common::protobuf_AddDesc_Security_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nhdfs.proto\022\013hadoop.hdfs\032\016Security.prot"
    "o\"c\n\022ExtendedBlockProto\022\016\n\006poolId\030\001 \002(\t\022"
    "\017\n\007blockId\030\002 \002(\004\022\027\n\017generationStamp\030\003 \002("
    "\004\022\023\n\010numBytes\030\004 \001(\004:\0010\"\231\001\n\017DatanodeIDPro"
    "to\022\016\n\006ipAddr\030\001 \002(\t\022\020\n\010hostName\030\002 \002(\t\022\024\n\014"
    "datanodeUuid\030\003 \002(\t\022\020\n\010xferPort\030\004 \002(\r\022\020\n\010"
    "infoPort\030\005 \002(\r\022\017\n\007ipcPort\030\006 \002(\r\022\031\n\016infoS"
    "ecurePort\030\007 \001(\r:\0010\"G\n\022DatanodeInfosProto"
    "\0221\n\tdatanodes\030\001 \003(\0132\036.hadoop.hdfs.Datano"
    "deInfoProto\"\232\003\n\021DatanodeInfoProto\022(\n\002id\030"
    "\001 \002(\0132\034.hadoop.hdfs.DatanodeIDProto\022\023\n\010c"
    "apacity\030\002 \001(\004:\0010\022\022\n\007dfsUsed\030\003 \001(\004:\0010\022\024\n\t"
    "remaining\030\004 \001(\004:\0010\022\030\n\rblockPoolUsed\030\005 \001("
    "\004:\0010\022\025\n\nlastUpdate\030\006 \001(\004:\0010\022\027\n\014xceiverCo"
    "unt\030\007 \001(\r:\0010\022\020\n\010location\030\010 \001(\t\022E\n\nadminS"
    "tate\030\n \001(\0162).hadoop.hdfs.DatanodeInfoPro"
    "to.AdminState:\006NORMAL\022\030\n\rcacheCapacity\030\013"
    " \001(\004:\0010\022\024\n\tcacheUsed\030\014 \001(\004:\0010\"I\n\nAdminSt"
    "ate\022\n\n\006NORMAL\020\000\022\033\n\027DECOMMISSION_INPROGRE"
    "SS\020\001\022\022\n\016DECOMMISSIONED\020\002\"\212\001\n\023ContentSumm"
    "aryProto\022\016\n\006length\030\001 \002(\004\022\021\n\tfileCount\030\002 "
    "\002(\004\022\026\n\016directoryCount\030\003 \002(\004\022\r\n\005quota\030\004 \002"
    "(\004\022\025\n\rspaceConsumed\030\005 \002(\004\022\022\n\nspaceQuota\030"
    "\006 \002(\004\"7\n\026CorruptFileBlocksProto\022\r\n\005files"
    "\030\001 \003(\t\022\016\n\006cookie\030\002 \002(\t\"!\n\021FsPermissionPr"
    "oto\022\014\n\004perm\030\001 \002(\r\")\n\021StorageUuidsProto\022\024"
    "\n\014storageUuids\030\001 \003(\t\"\234\002\n\021LocatedBlockPro"
    "to\022*\n\001b\030\001 \002(\0132\037.hadoop.hdfs.ExtendedBloc"
    "kProto\022\016\n\006offset\030\002 \002(\004\022,\n\004locs\030\003 \003(\0132\036.h"
    "adoop.hdfs.DatanodeInfoProto\022\017\n\007corrupt\030"
    "\004 \002(\010\022-\n\nblockToken\030\005 \002(\0132\031.hadoop.commo"
    "n.TokenProto\022\024\n\010isCached\030\006 \003(\010B\002\020\001\0223\n\014st"
    "orageTypes\030\007 \003(\0162\035.hadoop.hdfs.StorageTy"
    "peProto\022\022\n\nstorageIDs\030\010 \003(\t\"\223\001\n\026DataEncr"
    "yptionKeyProto\022\r\n\005keyId\030\001 \002(\r\022\023\n\013blockPo"
    "olId\030\002 \002(\t\022\r\n\005nonce\030\003 \002(\014\022\025\n\rencryptionK"
    "ey\030\004 \002(\014\022\022\n\nexpiryDate\030\005 \002(\004\022\033\n\023encrypti"
    "onAlgorithm\030\006 \001(\t\"\303\001\n\022LocatedBlocksProto"
    "\022\022\n\nfileLength\030\001 \002(\004\022.\n\006blocks\030\002 \003(\0132\036.h"
    "adoop.hdfs.LocatedBlockProto\022\031\n\021underCon"
    "struction\030\003 \002(\010\0221\n\tlastBlock\030\004 \001(\0132\036.had"
    "oop.hdfs.LocatedBlockProto\022\033\n\023isLastBloc"
    "kComplete\030\005 \002(\010\"\314\003\n\023HdfsFileStatusProto\022"
    ";\n\010fileType\030\001 \002(\0162).hadoop.hdfs.HdfsFile"
    "StatusProto.FileType\022\014\n\004path\030\002 \002(\014\022\016\n\006le"
    "ngth\030\003 \002(\004\0222\n\npermission\030\004 \002(\0132\036.hadoop."
    "hdfs.FsPermissionProto\022\r\n\005owner\030\005 \002(\t\022\r\n"
    "\005group\030\006 \002(\t\022\031\n\021modification_time\030\007 \002(\004\022"
    "\023\n\013access_time\030\010 \002(\004\022\017\n\007symlink\030\t \001(\014\022\034\n"
    "\021block_replication\030\n \001(\r:\0010\022\024\n\tblocksize"
    "\030\013 \001(\004:\0010\0222\n\tlocations\030\014 \001(\0132\037.hadoop.hd"
    "fs.LocatedBlocksProto\022\021\n\006fileId\030\r \001(\004:\0010"
    "\022\027\n\013childrenNum\030\016 \001(\005:\002-1\"3\n\010FileType\022\n\n"
    "\006IS_DIR\020\001\022\013\n\007IS_FILE\020\002\022\016\n\nIS_SYMLINK\020\003\"\216"
    "\002\n\025FsServerDefaultsProto\022\021\n\tblockSize\030\001 "
    "\002(\004\022\030\n\020bytesPerChecksum\030\002 \002(\r\022\027\n\017writePa"
    "cketSize\030\003 \002(\r\022\023\n\013replication\030\004 \002(\r\022\026\n\016f"
    "ileBufferSize\030\005 \002(\r\022\"\n\023encryptDataTransf"
    "er\030\006 \001(\010:\005false\022\030\n\rtrashInterval\030\007 \001(\004:\001"
    "0\022D\n\014checksumType\030\010 \001(\0162\036.hadoop.hdfs.Ch"
    "ecksumTypeProto:\016CHECKSUM_CRC32\"k\n\025Direc"
    "toryListingProto\0228\n\016partialListing\030\001 \003(\013"
    "2 .hadoop.hdfs.HdfsFileStatusProto\022\030\n\020re"
    "mainingEntries\030\002 \002(\r\"\242\001\n!SnapshottableDi"
    "rectoryStatusProto\0223\n\tdirStatus\030\001 \002(\0132 ."
    "hadoop.hdfs.HdfsFileStatusProto\022\026\n\016snaps"
    "hot_quota\030\002 \002(\r\022\027\n\017snapshot_number\030\003 \002(\r"
    "\022\027\n\017parent_fullpath\030\004 \002(\014\"u\n\"Snapshottab"
    "leDirectoryListingProto\022O\n\027snapshottable"
    "DirListing\030\001 \003(\0132..hadoop.hdfs.Snapshott"
    "ableDirectoryStatusProto\"K\n\034SnapshotDiff"
    "ReportEntryProto\022\020\n\010fullpath\030\001 \002(\014\022\031\n\021mo"
    "dificationLabel\030\002 \002(\t\"\237\001\n\027SnapshotDiffRe"
    "portProto\022\024\n\014snapshotRoot\030\001 \002(\t\022\024\n\014fromS"
    "napshot\030\002 \002(\t\022\022\n\ntoSnapshot\030\003 \002(\t\022D\n\021dif"
    "fReportEntries\030\004 \003(\0132).hadoop.hdfs.Snaps"
    "hotDiffReportEntryProto\"_\n\020StorageInfoPr"
    "oto\022\025\n\rlayoutVersion\030\001 \002(\r\022\022\n\nnamespceID"
    "\030\002 \002(\r\022\021\n\tclusterID\030\003 \002(\t\022\r\n\005cTime\030\004 \002(\004"
    "\"\211\002\n\031NamenodeRegistrationProto\022\022\n\nrpcAdd"
    "ress\030\001 \002(\t\022\023\n\013httpAddress\030\002 \002(\t\0222\n\013stora"
    "geInfo\030\003 \002(\0132\035.hadoop.hdfs.StorageInfoPr"
    "oto\022P\n\004role\030\004 \001(\01628.hadoop.hdfs.Namenode"
    "RegistrationProto.NamenodeRoleProto:\010NAM"
    "ENODE\"=\n\021NamenodeRoleProto\022\014\n\010NAMENODE\020\001"
    "\022\n\n\006BACKUP\020\002\022\016\n\nCHECKPOINT\020\003\"\235\001\n\030Checkpo"
    "intSignatureProto\022\023\n\013blockPoolId\030\001 \002(\t\022 "
    "\n\030mostRecentCheckpointTxId\030\002 \002(\004\022\026\n\016curS"
    "egmentTxId\030\003 \002(\004\0222\n\013storageInfo\030\004 \002(\0132\035."
    "hadoop.hdfs.StorageInfoProto\"\314\001\n\024Namenod"
    "eCommandProto\022\016\n\006action\030\001 \002(\r\0224\n\004type\030\002 "
    "\002(\0162&.hadoop.hdfs.NamenodeCommandProto.T"
    "ype\022:\n\rcheckpointCmd\030\003 \001(\0132#.hadoop.hdfs"
    ".CheckpointCommandProto\"2\n\004Type\022\023\n\017Namen"
    "odeCommand\020\000\022\025\n\021CheckPointCommand\020\001\"m\n\026C"
    "heckpointCommandProto\0228\n\tsignature\030\001 \002(\013"
    "2%.hadoop.hdfs.CheckpointSignatureProto\022"
    "\031\n\021needToReturnImage\030\002 \002(\010\"D\n\nBlockProto"
    "\022\017\n\007blockId\030\001 \002(\004\022\020\n\010genStamp\030\002 \002(\004\022\023\n\010n"
    "umBytes\030\003 \001(\004:\0010\"n\n\027BlockWithLocationsPr"
    "oto\022&\n\005block\030\001 \002(\0132\027.hadoop.hdfs.BlockPr"
    "oto\022\025\n\rdatanodeUuids\030\002 \003(\t\022\024\n\014storageUui"
    "ds\030\003 \003(\t\"P\n\030BlocksWithLocationsProto\0224\n\006"
    "blocks\030\001 \003(\0132$.hadoop.hdfs.BlockWithLoca"
    "tionsProto\"U\n\022RemoteEditLogProto\022\021\n\tstar"
    "tTxId\030\001 \002(\004\022\017\n\007endTxId\030\002 \002(\004\022\033\n\014isInProg"
    "ress\030\003 \001(\010:\005false\"K\n\032RemoteEditLogManife"
    "stProto\022-\n\004logs\030\001 \003(\0132\037.hadoop.hdfs.Remo"
    "teEditLogProto\"\234\001\n\022NamespaceInfoProto\022\024\n"
    "\014buildVersion\030\001 \002(\t\022\016\n\006unused\030\002 \002(\r\022\023\n\013b"
    "lockPoolID\030\003 \002(\t\0222\n\013storageInfo\030\004 \002(\0132\035."
    "hadoop.hdfs.StorageInfoProto\022\027\n\017software"
    "Version\030\005 \002(\t\"D\n\rBlockKeyProto\022\r\n\005keyId\030"
    "\001 \002(\r\022\022\n\nexpiryDate\030\002 \002(\004\022\020\n\010keyBytes\030\003 "
    "\001(\014\"\304\001\n\026ExportedBlockKeysProto\022\033\n\023isBloc"
    "kTokenEnabled\030\001 \002(\010\022\031\n\021keyUpdateInterval"
    "\030\002 \002(\004\022\025\n\rtokenLifeTime\030\003 \002(\004\022.\n\ncurrent"
    "Key\030\004 \002(\0132\032.hadoop.hdfs.BlockKeyProto\022+\n"
    "\007allKeys\030\005 \003(\0132\032.hadoop.hdfs.BlockKeyPro"
    "to\"Z\n\024RecoveringBlockProto\022\023\n\013newGenStam"
    "p\030\001 \002(\004\022-\n\005block\030\002 \002(\0132\036.hadoop.hdfs.Loc"
    "atedBlockProto\"\025\n\023VersionRequestProto\"E\n"
    "\024VersionResponseProto\022-\n\004info\030\001 \002(\0132\037.ha"
    "doop.hdfs.NamespaceInfoProto\"\245\001\n\021Snapsho"
    "tInfoProto\022\024\n\014snapshotName\030\001 \002(\t\022\024\n\014snap"
    "shotRoot\030\002 \002(\t\0222\n\npermission\030\003 \002(\0132\036.had"
    "oop.hdfs.FsPermissionProto\022\r\n\005owner\030\004 \002("
    "\t\022\r\n\005group\030\005 \002(\t\022\022\n\ncreateTime\030\006 \002(\t*%\n\020"
    "StorageTypeProto\022\010\n\004DISK\020\001\022\007\n\003SSD\020\002*O\n\021C"
    "hecksumTypeProto\022\021\n\rCHECKSUM_NULL\020\000\022\022\n\016C"
    "HECKSUM_CRC32\020\001\022\023\n\017CHECKSUM_CRC32C\020\002*L\n\021"
    "ReplicaStateProto\022\r\n\tFINALIZED\020\000\022\007\n\003RBW\020"
    "\001\022\007\n\003RWR\020\002\022\007\n\003RUR\020\003\022\r\n\tTEMPORARY\020\004B6\n%or"
    "g.apache.hadoop.hdfs.protocol.protoB\nHdf"
    "sProtos\240\001\001", 5370);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "hdfs.proto", &protobuf_RegisterTypes);
  ExtendedBlockProto::default_instance_ = new ExtendedBlockProto();
  DatanodeIDProto::default_instance_ = new DatanodeIDProto();
  DatanodeInfosProto::default_instance_ = new DatanodeInfosProto();
  DatanodeInfoProto::default_instance_ = new DatanodeInfoProto();
  ContentSummaryProto::default_instance_ = new ContentSummaryProto();
  CorruptFileBlocksProto::default_instance_ = new CorruptFileBlocksProto();
  FsPermissionProto::default_instance_ = new FsPermissionProto();
  StorageUuidsProto::default_instance_ = new StorageUuidsProto();
  LocatedBlockProto::default_instance_ = new LocatedBlockProto();
  DataEncryptionKeyProto::default_instance_ = new DataEncryptionKeyProto();
  LocatedBlocksProto::default_instance_ = new LocatedBlocksProto();
  HdfsFileStatusProto::default_instance_ = new HdfsFileStatusProto();
  FsServerDefaultsProto::default_instance_ = new FsServerDefaultsProto();
  DirectoryListingProto::default_instance_ = new DirectoryListingProto();
  SnapshottableDirectoryStatusProto::default_instance_ = new SnapshottableDirectoryStatusProto();
  SnapshottableDirectoryListingProto::default_instance_ = new SnapshottableDirectoryListingProto();
  SnapshotDiffReportEntryProto::default_instance_ = new SnapshotDiffReportEntryProto();
  SnapshotDiffReportProto::default_instance_ = new SnapshotDiffReportProto();
  StorageInfoProto::default_instance_ = new StorageInfoProto();
  NamenodeRegistrationProto::default_instance_ = new NamenodeRegistrationProto();
  CheckpointSignatureProto::default_instance_ = new CheckpointSignatureProto();
  NamenodeCommandProto::default_instance_ = new NamenodeCommandProto();
  CheckpointCommandProto::default_instance_ = new CheckpointCommandProto();
  BlockProto::default_instance_ = new BlockProto();
  BlockWithLocationsProto::default_instance_ = new BlockWithLocationsProto();
  BlocksWithLocationsProto::default_instance_ = new BlocksWithLocationsProto();
  RemoteEditLogProto::default_instance_ = new RemoteEditLogProto();
  RemoteEditLogManifestProto::default_instance_ = new RemoteEditLogManifestProto();
  NamespaceInfoProto::default_instance_ = new NamespaceInfoProto();
  BlockKeyProto::default_instance_ = new BlockKeyProto();
  ExportedBlockKeysProto::default_instance_ = new ExportedBlockKeysProto();
  RecoveringBlockProto::default_instance_ = new RecoveringBlockProto();
  VersionRequestProto::default_instance_ = new VersionRequestProto();
  VersionResponseProto::default_instance_ = new VersionResponseProto();
  SnapshotInfoProto::default_instance_ = new SnapshotInfoProto();
  ExtendedBlockProto::default_instance_->InitAsDefaultInstance();
  DatanodeIDProto::default_instance_->InitAsDefaultInstance();
  DatanodeInfosProto::default_instance_->InitAsDefaultInstance();
  DatanodeInfoProto::default_instance_->InitAsDefaultInstance();
  ContentSummaryProto::default_instance_->InitAsDefaultInstance();
  CorruptFileBlocksProto::default_instance_->InitAsDefaultInstance();
  FsPermissionProto::default_instance_->InitAsDefaultInstance();
  StorageUuidsProto::default_instance_->InitAsDefaultInstance();
  LocatedBlockProto::default_instance_->InitAsDefaultInstance();
  DataEncryptionKeyProto::default_instance_->InitAsDefaultInstance();
  LocatedBlocksProto::default_instance_->InitAsDefaultInstance();
  HdfsFileStatusProto::default_instance_->InitAsDefaultInstance();
  FsServerDefaultsProto::default_instance_->InitAsDefaultInstance();
  DirectoryListingProto::default_instance_->InitAsDefaultInstance();
  SnapshottableDirectoryStatusProto::default_instance_->InitAsDefaultInstance();
  SnapshottableDirectoryListingProto::default_instance_->InitAsDefaultInstance();
  SnapshotDiffReportEntryProto::default_instance_->InitAsDefaultInstance();
  SnapshotDiffReportProto::default_instance_->InitAsDefaultInstance();
  StorageInfoProto::default_instance_->InitAsDefaultInstance();
  NamenodeRegistrationProto::default_instance_->InitAsDefaultInstance();
  CheckpointSignatureProto::default_instance_->InitAsDefaultInstance();
  NamenodeCommandProto::default_instance_->InitAsDefaultInstance();
  CheckpointCommandProto::default_instance_->InitAsDefaultInstance();
  BlockProto::default_instance_->InitAsDefaultInstance();
  BlockWithLocationsProto::default_instance_->InitAsDefaultInstance();
  BlocksWithLocationsProto::default_instance_->InitAsDefaultInstance();
  RemoteEditLogProto::default_instance_->InitAsDefaultInstance();
  RemoteEditLogManifestProto::default_instance_->InitAsDefaultInstance();
  NamespaceInfoProto::default_instance_->InitAsDefaultInstance();
  BlockKeyProto::default_instance_->InitAsDefaultInstance();
  ExportedBlockKeysProto::default_instance_->InitAsDefaultInstance();
  RecoveringBlockProto::default_instance_->InitAsDefaultInstance();
  VersionRequestProto::default_instance_->InitAsDefaultInstance();
  VersionResponseProto::default_instance_->InitAsDefaultInstance();
  SnapshotInfoProto::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_hdfs_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_hdfs_2eproto {
  StaticDescriptorInitializer_hdfs_2eproto() {
    protobuf_AddDesc_hdfs_2eproto();
  }
} static_descriptor_initializer_hdfs_2eproto_;
const ::google::protobuf::EnumDescriptor* StorageTypeProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StorageTypeProto_descriptor_;
}
bool StorageTypeProto_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ChecksumTypeProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChecksumTypeProto_descriptor_;
}
bool ChecksumTypeProto_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ReplicaStateProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplicaStateProto_descriptor_;
}
bool ReplicaStateProto_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int ExtendedBlockProto::kPoolIdFieldNumber;
const int ExtendedBlockProto::kBlockIdFieldNumber;
const int ExtendedBlockProto::kGenerationStampFieldNumber;
const int ExtendedBlockProto::kNumBytesFieldNumber;
#endif  // !_MSC_VER

ExtendedBlockProto::ExtendedBlockProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ExtendedBlockProto::InitAsDefaultInstance() {
}

ExtendedBlockProto::ExtendedBlockProto(const ExtendedBlockProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ExtendedBlockProto::SharedCtor() {
  _cached_size_ = 0;
  poolid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  blockid_ = GOOGLE_ULONGLONG(0);
  generationstamp_ = GOOGLE_ULONGLONG(0);
  numbytes_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExtendedBlockProto::~ExtendedBlockProto() {
  SharedDtor();
}

void ExtendedBlockProto::SharedDtor() {
  if (poolid_ != &::google::protobuf::internal::kEmptyString) {
    delete poolid_;
  }
  if (this != default_instance_) {
  }
}

void ExtendedBlockProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExtendedBlockProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExtendedBlockProto_descriptor_;
}

const ExtendedBlockProto& ExtendedBlockProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

ExtendedBlockProto* ExtendedBlockProto::default_instance_ = NULL;

ExtendedBlockProto* ExtendedBlockProto::New() const {
  return new ExtendedBlockProto;
}

void ExtendedBlockProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_poolid()) {
      if (poolid_ != &::google::protobuf::internal::kEmptyString) {
        poolid_->clear();
      }
    }
    blockid_ = GOOGLE_ULONGLONG(0);
    generationstamp_ = GOOGLE_ULONGLONG(0);
    numbytes_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExtendedBlockProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string poolId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_poolid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->poolid().data(), this->poolid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_blockId;
        break;
      }

      // required uint64 blockId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blockId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blockid_)));
          set_has_blockid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_generationStamp;
        break;
      }

      // required uint64 generationStamp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_generationStamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &generationstamp_)));
          set_has_generationstamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_numBytes;
        break;
      }

      // optional uint64 numBytes = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &numbytes_)));
          set_has_numbytes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExtendedBlockProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string poolId = 1;
  if (has_poolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->poolid().data(), this->poolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->poolid(), output);
  }

  // required uint64 blockId = 2;
  if (has_blockid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->blockid(), output);
  }

  // required uint64 generationStamp = 3;
  if (has_generationstamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->generationstamp(), output);
  }

  // optional uint64 numBytes = 4 [default = 0];
  if (has_numbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->numbytes(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ExtendedBlockProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string poolId = 1;
  if (has_poolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->poolid().data(), this->poolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->poolid(), target);
  }

  // required uint64 blockId = 2;
  if (has_blockid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->blockid(), target);
  }

  // required uint64 generationStamp = 3;
  if (has_generationstamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->generationstamp(), target);
  }

  // optional uint64 numBytes = 4 [default = 0];
  if (has_numbytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->numbytes(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ExtendedBlockProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string poolId = 1;
    if (has_poolid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->poolid());
    }

    // required uint64 blockId = 2;
    if (has_blockid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blockid());
    }

    // required uint64 generationStamp = 3;
    if (has_generationstamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->generationstamp());
    }

    // optional uint64 numBytes = 4 [default = 0];
    if (has_numbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->numbytes());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExtendedBlockProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExtendedBlockProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExtendedBlockProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExtendedBlockProto::MergeFrom(const ExtendedBlockProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_poolid()) {
      set_poolid(from.poolid());
    }
    if (from.has_blockid()) {
      set_blockid(from.blockid());
    }
    if (from.has_generationstamp()) {
      set_generationstamp(from.generationstamp());
    }
    if (from.has_numbytes()) {
      set_numbytes(from.numbytes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExtendedBlockProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExtendedBlockProto::CopyFrom(const ExtendedBlockProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtendedBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ExtendedBlockProto::Swap(ExtendedBlockProto* other) {
  if (other != this) {
    std::swap(poolid_, other->poolid_);
    std::swap(blockid_, other->blockid_);
    std::swap(generationstamp_, other->generationstamp_);
    std::swap(numbytes_, other->numbytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExtendedBlockProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExtendedBlockProto_descriptor_;
  metadata.reflection = ExtendedBlockProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DatanodeIDProto::kIpAddrFieldNumber;
const int DatanodeIDProto::kHostNameFieldNumber;
const int DatanodeIDProto::kDatanodeUuidFieldNumber;
const int DatanodeIDProto::kXferPortFieldNumber;
const int DatanodeIDProto::kInfoPortFieldNumber;
const int DatanodeIDProto::kIpcPortFieldNumber;
const int DatanodeIDProto::kInfoSecurePortFieldNumber;
#endif  // !_MSC_VER

DatanodeIDProto::DatanodeIDProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DatanodeIDProto::InitAsDefaultInstance() {
}

DatanodeIDProto::DatanodeIDProto(const DatanodeIDProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DatanodeIDProto::SharedCtor() {
  _cached_size_ = 0;
  ipaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  datanodeuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  xferport_ = 0u;
  infoport_ = 0u;
  ipcport_ = 0u;
  infosecureport_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DatanodeIDProto::~DatanodeIDProto() {
  SharedDtor();
}

void DatanodeIDProto::SharedDtor() {
  if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddr_;
  }
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (datanodeuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete datanodeuuid_;
  }
  if (this != default_instance_) {
  }
}

void DatanodeIDProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DatanodeIDProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeIDProto_descriptor_;
}

const DatanodeIDProto& DatanodeIDProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

DatanodeIDProto* DatanodeIDProto::default_instance_ = NULL;

DatanodeIDProto* DatanodeIDProto::New() const {
  return new DatanodeIDProto;
}

void DatanodeIDProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ipaddr()) {
      if (ipaddr_ != &::google::protobuf::internal::kEmptyString) {
        ipaddr_->clear();
      }
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::kEmptyString) {
        hostname_->clear();
      }
    }
    if (has_datanodeuuid()) {
      if (datanodeuuid_ != &::google::protobuf::internal::kEmptyString) {
        datanodeuuid_->clear();
      }
    }
    xferport_ = 0u;
    infoport_ = 0u;
    ipcport_ = 0u;
    infosecureport_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DatanodeIDProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ipAddr = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ipaddr()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ipaddr().data(), this->ipaddr().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hostName;
        break;
      }

      // required string hostName = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hostName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_datanodeUuid;
        break;
      }

      // required string datanodeUuid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_datanodeUuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_datanodeuuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->datanodeuuid().data(), this->datanodeuuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_xferPort;
        break;
      }

      // required uint32 xferPort = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_xferPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &xferport_)));
          set_has_xferport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_infoPort;
        break;
      }

      // required uint32 infoPort = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_infoPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &infoport_)));
          set_has_infoport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_ipcPort;
        break;
      }

      // required uint32 ipcPort = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ipcPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ipcport_)));
          set_has_ipcport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_infoSecurePort;
        break;
      }

      // optional uint32 infoSecurePort = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_infoSecurePort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &infosecureport_)));
          set_has_infosecureport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DatanodeIDProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string ipAddr = 1;
  if (has_ipaddr()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ipaddr().data(), this->ipaddr().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ipaddr(), output);
  }

  // required string hostName = 2;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->hostname(), output);
  }

  // required string datanodeUuid = 3;
  if (has_datanodeuuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->datanodeuuid().data(), this->datanodeuuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->datanodeuuid(), output);
  }

  // required uint32 xferPort = 4;
  if (has_xferport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->xferport(), output);
  }

  // required uint32 infoPort = 5;
  if (has_infoport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->infoport(), output);
  }

  // required uint32 ipcPort = 6;
  if (has_ipcport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->ipcport(), output);
  }

  // optional uint32 infoSecurePort = 7 [default = 0];
  if (has_infosecureport()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->infosecureport(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DatanodeIDProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string ipAddr = 1;
  if (has_ipaddr()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ipaddr().data(), this->ipaddr().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ipaddr(), target);
  }

  // required string hostName = 2;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->hostname(), target);
  }

  // required string datanodeUuid = 3;
  if (has_datanodeuuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->datanodeuuid().data(), this->datanodeuuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->datanodeuuid(), target);
  }

  // required uint32 xferPort = 4;
  if (has_xferport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->xferport(), target);
  }

  // required uint32 infoPort = 5;
  if (has_infoport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->infoport(), target);
  }

  // required uint32 ipcPort = 6;
  if (has_ipcport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->ipcport(), target);
  }

  // optional uint32 infoSecurePort = 7 [default = 0];
  if (has_infosecureport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->infosecureport(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DatanodeIDProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ipAddr = 1;
    if (has_ipaddr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ipaddr());
    }

    // required string hostName = 2;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // required string datanodeUuid = 3;
    if (has_datanodeuuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->datanodeuuid());
    }

    // required uint32 xferPort = 4;
    if (has_xferport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->xferport());
    }

    // required uint32 infoPort = 5;
    if (has_infoport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->infoport());
    }

    // required uint32 ipcPort = 6;
    if (has_ipcport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ipcport());
    }

    // optional uint32 infoSecurePort = 7 [default = 0];
    if (has_infosecureport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->infosecureport());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DatanodeIDProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DatanodeIDProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DatanodeIDProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DatanodeIDProto::MergeFrom(const DatanodeIDProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ipaddr()) {
      set_ipaddr(from.ipaddr());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_datanodeuuid()) {
      set_datanodeuuid(from.datanodeuuid());
    }
    if (from.has_xferport()) {
      set_xferport(from.xferport());
    }
    if (from.has_infoport()) {
      set_infoport(from.infoport());
    }
    if (from.has_ipcport()) {
      set_ipcport(from.ipcport());
    }
    if (from.has_infosecureport()) {
      set_infosecureport(from.infosecureport());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DatanodeIDProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeIDProto::CopyFrom(const DatanodeIDProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeIDProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void DatanodeIDProto::Swap(DatanodeIDProto* other) {
  if (other != this) {
    std::swap(ipaddr_, other->ipaddr_);
    std::swap(hostname_, other->hostname_);
    std::swap(datanodeuuid_, other->datanodeuuid_);
    std::swap(xferport_, other->xferport_);
    std::swap(infoport_, other->infoport_);
    std::swap(ipcport_, other->ipcport_);
    std::swap(infosecureport_, other->infosecureport_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DatanodeIDProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DatanodeIDProto_descriptor_;
  metadata.reflection = DatanodeIDProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DatanodeInfosProto::kDatanodesFieldNumber;
#endif  // !_MSC_VER

DatanodeInfosProto::DatanodeInfosProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DatanodeInfosProto::InitAsDefaultInstance() {
}

DatanodeInfosProto::DatanodeInfosProto(const DatanodeInfosProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DatanodeInfosProto::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DatanodeInfosProto::~DatanodeInfosProto() {
  SharedDtor();
}

void DatanodeInfosProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DatanodeInfosProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DatanodeInfosProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeInfosProto_descriptor_;
}

const DatanodeInfosProto& DatanodeInfosProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

DatanodeInfosProto* DatanodeInfosProto::default_instance_ = NULL;

DatanodeInfosProto* DatanodeInfosProto::New() const {
  return new DatanodeInfosProto;
}

void DatanodeInfosProto::Clear() {
  datanodes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DatanodeInfosProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hadoop.hdfs.DatanodeInfoProto datanodes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_datanodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_datanodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_datanodes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DatanodeInfosProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hadoop.hdfs.DatanodeInfoProto datanodes = 1;
  for (int i = 0; i < this->datanodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->datanodes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DatanodeInfosProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hadoop.hdfs.DatanodeInfoProto datanodes = 1;
  for (int i = 0; i < this->datanodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->datanodes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DatanodeInfosProto::ByteSize() const {
  int total_size = 0;

  // repeated .hadoop.hdfs.DatanodeInfoProto datanodes = 1;
  total_size += 1 * this->datanodes_size();
  for (int i = 0; i < this->datanodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->datanodes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DatanodeInfosProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DatanodeInfosProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DatanodeInfosProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DatanodeInfosProto::MergeFrom(const DatanodeInfosProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  datanodes_.MergeFrom(from.datanodes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DatanodeInfosProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeInfosProto::CopyFrom(const DatanodeInfosProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeInfosProto::IsInitialized() const {

  for (int i = 0; i < datanodes_size(); i++) {
    if (!this->datanodes(i).IsInitialized()) return false;
  }
  return true;
}

void DatanodeInfosProto::Swap(DatanodeInfosProto* other) {
  if (other != this) {
    datanodes_.Swap(&other->datanodes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DatanodeInfosProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DatanodeInfosProto_descriptor_;
  metadata.reflection = DatanodeInfosProto_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* DatanodeInfoProto_AdminState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeInfoProto_AdminState_descriptor_;
}
bool DatanodeInfoProto_AdminState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DatanodeInfoProto_AdminState DatanodeInfoProto::NORMAL;
const DatanodeInfoProto_AdminState DatanodeInfoProto::DECOMMISSION_INPROGRESS;
const DatanodeInfoProto_AdminState DatanodeInfoProto::DECOMMISSIONED;
const DatanodeInfoProto_AdminState DatanodeInfoProto::AdminState_MIN;
const DatanodeInfoProto_AdminState DatanodeInfoProto::AdminState_MAX;
const int DatanodeInfoProto::AdminState_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int DatanodeInfoProto::kIdFieldNumber;
const int DatanodeInfoProto::kCapacityFieldNumber;
const int DatanodeInfoProto::kDfsUsedFieldNumber;
const int DatanodeInfoProto::kRemainingFieldNumber;
const int DatanodeInfoProto::kBlockPoolUsedFieldNumber;
const int DatanodeInfoProto::kLastUpdateFieldNumber;
const int DatanodeInfoProto::kXceiverCountFieldNumber;
const int DatanodeInfoProto::kLocationFieldNumber;
const int DatanodeInfoProto::kAdminStateFieldNumber;
const int DatanodeInfoProto::kCacheCapacityFieldNumber;
const int DatanodeInfoProto::kCacheUsedFieldNumber;
#endif  // !_MSC_VER

DatanodeInfoProto::DatanodeInfoProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DatanodeInfoProto::InitAsDefaultInstance() {
  id_ = const_cast< ::hadoop::hdfs::DatanodeIDProto*>(&::hadoop::hdfs::DatanodeIDProto::default_instance());
}

DatanodeInfoProto::DatanodeInfoProto(const DatanodeInfoProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DatanodeInfoProto::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  capacity_ = GOOGLE_ULONGLONG(0);
  dfsused_ = GOOGLE_ULONGLONG(0);
  remaining_ = GOOGLE_ULONGLONG(0);
  blockpoolused_ = GOOGLE_ULONGLONG(0);
  lastupdate_ = GOOGLE_ULONGLONG(0);
  xceivercount_ = 0u;
  location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  adminstate_ = 0;
  cachecapacity_ = GOOGLE_ULONGLONG(0);
  cacheused_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DatanodeInfoProto::~DatanodeInfoProto() {
  SharedDtor();
}

void DatanodeInfoProto::SharedDtor() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (this != default_instance_) {
    delete id_;
  }
}

void DatanodeInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DatanodeInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DatanodeInfoProto_descriptor_;
}

const DatanodeInfoProto& DatanodeInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

DatanodeInfoProto* DatanodeInfoProto::default_instance_ = NULL;

DatanodeInfoProto* DatanodeInfoProto::New() const {
  return new DatanodeInfoProto;
}

void DatanodeInfoProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != NULL) id_->::hadoop::hdfs::DatanodeIDProto::Clear();
    }
    capacity_ = GOOGLE_ULONGLONG(0);
    dfsused_ = GOOGLE_ULONGLONG(0);
    remaining_ = GOOGLE_ULONGLONG(0);
    blockpoolused_ = GOOGLE_ULONGLONG(0);
    lastupdate_ = GOOGLE_ULONGLONG(0);
    xceivercount_ = 0u;
    if (has_location()) {
      if (location_ != &::google::protobuf::internal::kEmptyString) {
        location_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    adminstate_ = 0;
    cachecapacity_ = GOOGLE_ULONGLONG(0);
    cacheused_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DatanodeInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hadoop.hdfs.DatanodeIDProto id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_capacity;
        break;
      }

      // optional uint64 capacity = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_dfsUsed;
        break;
      }

      // optional uint64 dfsUsed = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dfsUsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dfsused_)));
          set_has_dfsused();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_remaining;
        break;
      }

      // optional uint64 remaining = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remaining:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &remaining_)));
          set_has_remaining();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_blockPoolUsed;
        break;
      }

      // optional uint64 blockPoolUsed = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blockPoolUsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blockpoolused_)));
          set_has_blockpoolused();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_lastUpdate;
        break;
      }

      // optional uint64 lastUpdate = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lastUpdate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &lastupdate_)));
          set_has_lastupdate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_xceiverCount;
        break;
      }

      // optional uint32 xceiverCount = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_xceiverCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &xceivercount_)));
          set_has_xceivercount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_location;
        break;
      }

      // optional string location = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_location()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->location().data(), this->location().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_adminState;
        break;
      }

      // optional .hadoop.hdfs.DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_adminState:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hadoop::hdfs::DatanodeInfoProto_AdminState_IsValid(value)) {
            set_adminstate(static_cast< ::hadoop::hdfs::DatanodeInfoProto_AdminState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_cacheCapacity;
        break;
      }

      // optional uint64 cacheCapacity = 11 [default = 0];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cacheCapacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cachecapacity_)));
          set_has_cachecapacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_cacheUsed;
        break;
      }

      // optional uint64 cacheUsed = 12 [default = 0];
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cacheUsed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cacheused_)));
          set_has_cacheused();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DatanodeInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hadoop.hdfs.DatanodeIDProto id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->id(), output);
  }

  // optional uint64 capacity = 2 [default = 0];
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->capacity(), output);
  }

  // optional uint64 dfsUsed = 3 [default = 0];
  if (has_dfsused()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->dfsused(), output);
  }

  // optional uint64 remaining = 4 [default = 0];
  if (has_remaining()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->remaining(), output);
  }

  // optional uint64 blockPoolUsed = 5 [default = 0];
  if (has_blockpoolused()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->blockpoolused(), output);
  }

  // optional uint64 lastUpdate = 6 [default = 0];
  if (has_lastupdate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->lastupdate(), output);
  }

  // optional uint32 xceiverCount = 7 [default = 0];
  if (has_xceivercount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->xceivercount(), output);
  }

  // optional string location = 8;
  if (has_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->location(), output);
  }

  // optional .hadoop.hdfs.DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
  if (has_adminstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->adminstate(), output);
  }

  // optional uint64 cacheCapacity = 11 [default = 0];
  if (has_cachecapacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->cachecapacity(), output);
  }

  // optional uint64 cacheUsed = 12 [default = 0];
  if (has_cacheused()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->cacheused(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DatanodeInfoProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hadoop.hdfs.DatanodeIDProto id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->id(), target);
  }

  // optional uint64 capacity = 2 [default = 0];
  if (has_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->capacity(), target);
  }

  // optional uint64 dfsUsed = 3 [default = 0];
  if (has_dfsused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->dfsused(), target);
  }

  // optional uint64 remaining = 4 [default = 0];
  if (has_remaining()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->remaining(), target);
  }

  // optional uint64 blockPoolUsed = 5 [default = 0];
  if (has_blockpoolused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->blockpoolused(), target);
  }

  // optional uint64 lastUpdate = 6 [default = 0];
  if (has_lastupdate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->lastupdate(), target);
  }

  // optional uint32 xceiverCount = 7 [default = 0];
  if (has_xceivercount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->xceivercount(), target);
  }

  // optional string location = 8;
  if (has_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->location(), target);
  }

  // optional .hadoop.hdfs.DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
  if (has_adminstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->adminstate(), target);
  }

  // optional uint64 cacheCapacity = 11 [default = 0];
  if (has_cachecapacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->cachecapacity(), target);
  }

  // optional uint64 cacheUsed = 12 [default = 0];
  if (has_cacheused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(12, this->cacheused(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DatanodeInfoProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hadoop.hdfs.DatanodeIDProto id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id());
    }

    // optional uint64 capacity = 2 [default = 0];
    if (has_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->capacity());
    }

    // optional uint64 dfsUsed = 3 [default = 0];
    if (has_dfsused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dfsused());
    }

    // optional uint64 remaining = 4 [default = 0];
    if (has_remaining()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->remaining());
    }

    // optional uint64 blockPoolUsed = 5 [default = 0];
    if (has_blockpoolused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blockpoolused());
    }

    // optional uint64 lastUpdate = 6 [default = 0];
    if (has_lastupdate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->lastupdate());
    }

    // optional uint32 xceiverCount = 7 [default = 0];
    if (has_xceivercount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->xceivercount());
    }

    // optional string location = 8;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->location());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .hadoop.hdfs.DatanodeInfoProto.AdminState adminState = 10 [default = NORMAL];
    if (has_adminstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->adminstate());
    }

    // optional uint64 cacheCapacity = 11 [default = 0];
    if (has_cachecapacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cachecapacity());
    }

    // optional uint64 cacheUsed = 12 [default = 0];
    if (has_cacheused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cacheused());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DatanodeInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DatanodeInfoProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DatanodeInfoProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DatanodeInfoProto::MergeFrom(const DatanodeInfoProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::hadoop::hdfs::DatanodeIDProto::MergeFrom(from.id());
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
    if (from.has_dfsused()) {
      set_dfsused(from.dfsused());
    }
    if (from.has_remaining()) {
      set_remaining(from.remaining());
    }
    if (from.has_blockpoolused()) {
      set_blockpoolused(from.blockpoolused());
    }
    if (from.has_lastupdate()) {
      set_lastupdate(from.lastupdate());
    }
    if (from.has_xceivercount()) {
      set_xceivercount(from.xceivercount());
    }
    if (from.has_location()) {
      set_location(from.location());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_adminstate()) {
      set_adminstate(from.adminstate());
    }
    if (from.has_cachecapacity()) {
      set_cachecapacity(from.cachecapacity());
    }
    if (from.has_cacheused()) {
      set_cacheused(from.cacheused());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DatanodeInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeInfoProto::CopyFrom(const DatanodeInfoProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_id()) {
    if (!this->id().IsInitialized()) return false;
  }
  return true;
}

void DatanodeInfoProto::Swap(DatanodeInfoProto* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(capacity_, other->capacity_);
    std::swap(dfsused_, other->dfsused_);
    std::swap(remaining_, other->remaining_);
    std::swap(blockpoolused_, other->blockpoolused_);
    std::swap(lastupdate_, other->lastupdate_);
    std::swap(xceivercount_, other->xceivercount_);
    std::swap(location_, other->location_);
    std::swap(adminstate_, other->adminstate_);
    std::swap(cachecapacity_, other->cachecapacity_);
    std::swap(cacheused_, other->cacheused_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DatanodeInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DatanodeInfoProto_descriptor_;
  metadata.reflection = DatanodeInfoProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ContentSummaryProto::kLengthFieldNumber;
const int ContentSummaryProto::kFileCountFieldNumber;
const int ContentSummaryProto::kDirectoryCountFieldNumber;
const int ContentSummaryProto::kQuotaFieldNumber;
const int ContentSummaryProto::kSpaceConsumedFieldNumber;
const int ContentSummaryProto::kSpaceQuotaFieldNumber;
#endif  // !_MSC_VER

ContentSummaryProto::ContentSummaryProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ContentSummaryProto::InitAsDefaultInstance() {
}

ContentSummaryProto::ContentSummaryProto(const ContentSummaryProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ContentSummaryProto::SharedCtor() {
  _cached_size_ = 0;
  length_ = GOOGLE_ULONGLONG(0);
  filecount_ = GOOGLE_ULONGLONG(0);
  directorycount_ = GOOGLE_ULONGLONG(0);
  quota_ = GOOGLE_ULONGLONG(0);
  spaceconsumed_ = GOOGLE_ULONGLONG(0);
  spacequota_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContentSummaryProto::~ContentSummaryProto() {
  SharedDtor();
}

void ContentSummaryProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ContentSummaryProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContentSummaryProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContentSummaryProto_descriptor_;
}

const ContentSummaryProto& ContentSummaryProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

ContentSummaryProto* ContentSummaryProto::default_instance_ = NULL;

ContentSummaryProto* ContentSummaryProto::New() const {
  return new ContentSummaryProto;
}

void ContentSummaryProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    length_ = GOOGLE_ULONGLONG(0);
    filecount_ = GOOGLE_ULONGLONG(0);
    directorycount_ = GOOGLE_ULONGLONG(0);
    quota_ = GOOGLE_ULONGLONG(0);
    spaceconsumed_ = GOOGLE_ULONGLONG(0);
    spacequota_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ContentSummaryProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 length = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fileCount;
        break;
      }

      // required uint64 fileCount = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fileCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &filecount_)));
          set_has_filecount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_directoryCount;
        break;
      }

      // required uint64 directoryCount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_directoryCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &directorycount_)));
          set_has_directorycount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_quota;
        break;
      }

      // required uint64 quota = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_quota:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_)));
          set_has_quota();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_spaceConsumed;
        break;
      }

      // required uint64 spaceConsumed = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_spaceConsumed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &spaceconsumed_)));
          set_has_spaceconsumed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_spaceQuota;
        break;
      }

      // required uint64 spaceQuota = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_spaceQuota:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &spacequota_)));
          set_has_spacequota();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ContentSummaryProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 length = 1;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->length(), output);
  }

  // required uint64 fileCount = 2;
  if (has_filecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->filecount(), output);
  }

  // required uint64 directoryCount = 3;
  if (has_directorycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->directorycount(), output);
  }

  // required uint64 quota = 4;
  if (has_quota()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->quota(), output);
  }

  // required uint64 spaceConsumed = 5;
  if (has_spaceconsumed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->spaceconsumed(), output);
  }

  // required uint64 spaceQuota = 6;
  if (has_spacequota()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->spacequota(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ContentSummaryProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 length = 1;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->length(), target);
  }

  // required uint64 fileCount = 2;
  if (has_filecount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->filecount(), target);
  }

  // required uint64 directoryCount = 3;
  if (has_directorycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->directorycount(), target);
  }

  // required uint64 quota = 4;
  if (has_quota()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->quota(), target);
  }

  // required uint64 spaceConsumed = 5;
  if (has_spaceconsumed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->spaceconsumed(), target);
  }

  // required uint64 spaceQuota = 6;
  if (has_spacequota()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->spacequota(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ContentSummaryProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 length = 1;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->length());
    }

    // required uint64 fileCount = 2;
    if (has_filecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->filecount());
    }

    // required uint64 directoryCount = 3;
    if (has_directorycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->directorycount());
    }

    // required uint64 quota = 4;
    if (has_quota()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quota());
    }

    // required uint64 spaceConsumed = 5;
    if (has_spaceconsumed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->spaceconsumed());
    }

    // required uint64 spaceQuota = 6;
    if (has_spacequota()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->spacequota());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContentSummaryProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ContentSummaryProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ContentSummaryProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ContentSummaryProto::MergeFrom(const ContentSummaryProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_filecount()) {
      set_filecount(from.filecount());
    }
    if (from.has_directorycount()) {
      set_directorycount(from.directorycount());
    }
    if (from.has_quota()) {
      set_quota(from.quota());
    }
    if (from.has_spaceconsumed()) {
      set_spaceconsumed(from.spaceconsumed());
    }
    if (from.has_spacequota()) {
      set_spacequota(from.spacequota());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ContentSummaryProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContentSummaryProto::CopyFrom(const ContentSummaryProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentSummaryProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void ContentSummaryProto::Swap(ContentSummaryProto* other) {
  if (other != this) {
    std::swap(length_, other->length_);
    std::swap(filecount_, other->filecount_);
    std::swap(directorycount_, other->directorycount_);
    std::swap(quota_, other->quota_);
    std::swap(spaceconsumed_, other->spaceconsumed_);
    std::swap(spacequota_, other->spacequota_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ContentSummaryProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContentSummaryProto_descriptor_;
  metadata.reflection = ContentSummaryProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CorruptFileBlocksProto::kFilesFieldNumber;
const int CorruptFileBlocksProto::kCookieFieldNumber;
#endif  // !_MSC_VER

CorruptFileBlocksProto::CorruptFileBlocksProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CorruptFileBlocksProto::InitAsDefaultInstance() {
}

CorruptFileBlocksProto::CorruptFileBlocksProto(const CorruptFileBlocksProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CorruptFileBlocksProto::SharedCtor() {
  _cached_size_ = 0;
  cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CorruptFileBlocksProto::~CorruptFileBlocksProto() {
  SharedDtor();
}

void CorruptFileBlocksProto::SharedDtor() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (this != default_instance_) {
  }
}

void CorruptFileBlocksProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CorruptFileBlocksProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CorruptFileBlocksProto_descriptor_;
}

const CorruptFileBlocksProto& CorruptFileBlocksProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

CorruptFileBlocksProto* CorruptFileBlocksProto::default_instance_ = NULL;

CorruptFileBlocksProto* CorruptFileBlocksProto::New() const {
  return new CorruptFileBlocksProto;
}

void CorruptFileBlocksProto::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_cookie()) {
      if (cookie_ != &::google::protobuf::internal::kEmptyString) {
        cookie_->clear();
      }
    }
  }
  files_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CorruptFileBlocksProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string files = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_files:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_files()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->files(this->files_size() - 1).data(),
            this->files(this->files_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_files;
        if (input->ExpectTag(18)) goto parse_cookie;
        break;
      }

      // required string cookie = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cookie:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cookie()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->cookie().data(), this->cookie().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CorruptFileBlocksProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string files = 1;
  for (int i = 0; i < this->files_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->files(i).data(), this->files(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->files(i), output);
  }

  // required string cookie = 2;
  if (has_cookie()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cookie().data(), this->cookie().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->cookie(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CorruptFileBlocksProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated string files = 1;
  for (int i = 0; i < this->files_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->files(i).data(), this->files(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->files(i), target);
  }

  // required string cookie = 2;
  if (has_cookie()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cookie().data(), this->cookie().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->cookie(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CorruptFileBlocksProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required string cookie = 2;
    if (has_cookie()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cookie());
    }

  }
  // repeated string files = 1;
  total_size += 1 * this->files_size();
  for (int i = 0; i < this->files_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->files(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CorruptFileBlocksProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CorruptFileBlocksProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CorruptFileBlocksProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CorruptFileBlocksProto::MergeFrom(const CorruptFileBlocksProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  files_.MergeFrom(from.files_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_cookie()) {
      set_cookie(from.cookie());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CorruptFileBlocksProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CorruptFileBlocksProto::CopyFrom(const CorruptFileBlocksProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CorruptFileBlocksProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void CorruptFileBlocksProto::Swap(CorruptFileBlocksProto* other) {
  if (other != this) {
    files_.Swap(&other->files_);
    std::swap(cookie_, other->cookie_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CorruptFileBlocksProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CorruptFileBlocksProto_descriptor_;
  metadata.reflection = CorruptFileBlocksProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FsPermissionProto::kPermFieldNumber;
#endif  // !_MSC_VER

FsPermissionProto::FsPermissionProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FsPermissionProto::InitAsDefaultInstance() {
}

FsPermissionProto::FsPermissionProto(const FsPermissionProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FsPermissionProto::SharedCtor() {
  _cached_size_ = 0;
  perm_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FsPermissionProto::~FsPermissionProto() {
  SharedDtor();
}

void FsPermissionProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FsPermissionProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FsPermissionProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FsPermissionProto_descriptor_;
}

const FsPermissionProto& FsPermissionProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

FsPermissionProto* FsPermissionProto::default_instance_ = NULL;

FsPermissionProto* FsPermissionProto::New() const {
  return new FsPermissionProto;
}

void FsPermissionProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    perm_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FsPermissionProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 perm = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &perm_)));
          set_has_perm();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FsPermissionProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 perm = 1;
  if (has_perm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->perm(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FsPermissionProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 perm = 1;
  if (has_perm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->perm(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FsPermissionProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 perm = 1;
    if (has_perm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->perm());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FsPermissionProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FsPermissionProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FsPermissionProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FsPermissionProto::MergeFrom(const FsPermissionProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_perm()) {
      set_perm(from.perm());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FsPermissionProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FsPermissionProto::CopyFrom(const FsPermissionProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FsPermissionProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FsPermissionProto::Swap(FsPermissionProto* other) {
  if (other != this) {
    std::swap(perm_, other->perm_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FsPermissionProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FsPermissionProto_descriptor_;
  metadata.reflection = FsPermissionProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StorageUuidsProto::kStorageUuidsFieldNumber;
#endif  // !_MSC_VER

StorageUuidsProto::StorageUuidsProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StorageUuidsProto::InitAsDefaultInstance() {
}

StorageUuidsProto::StorageUuidsProto(const StorageUuidsProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StorageUuidsProto::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StorageUuidsProto::~StorageUuidsProto() {
  SharedDtor();
}

void StorageUuidsProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StorageUuidsProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StorageUuidsProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StorageUuidsProto_descriptor_;
}

const StorageUuidsProto& StorageUuidsProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

StorageUuidsProto* StorageUuidsProto::default_instance_ = NULL;

StorageUuidsProto* StorageUuidsProto::New() const {
  return new StorageUuidsProto;
}

void StorageUuidsProto::Clear() {
  storageuuids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StorageUuidsProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string storageUuids = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_storageUuids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_storageuuids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->storageuuids(this->storageuuids_size() - 1).data(),
            this->storageuuids(this->storageuuids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_storageUuids;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StorageUuidsProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string storageUuids = 1;
  for (int i = 0; i < this->storageuuids_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->storageuuids(i).data(), this->storageuuids(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->storageuuids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StorageUuidsProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated string storageUuids = 1;
  for (int i = 0; i < this->storageuuids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->storageuuids(i).data(), this->storageuuids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->storageuuids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StorageUuidsProto::ByteSize() const {
  int total_size = 0;

  // repeated string storageUuids = 1;
  total_size += 1 * this->storageuuids_size();
  for (int i = 0; i < this->storageuuids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->storageuuids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StorageUuidsProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StorageUuidsProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StorageUuidsProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StorageUuidsProto::MergeFrom(const StorageUuidsProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  storageuuids_.MergeFrom(from.storageuuids_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StorageUuidsProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StorageUuidsProto::CopyFrom(const StorageUuidsProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageUuidsProto::IsInitialized() const {

  return true;
}

void StorageUuidsProto::Swap(StorageUuidsProto* other) {
  if (other != this) {
    storageuuids_.Swap(&other->storageuuids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StorageUuidsProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StorageUuidsProto_descriptor_;
  metadata.reflection = StorageUuidsProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LocatedBlockProto::kBFieldNumber;
const int LocatedBlockProto::kOffsetFieldNumber;
const int LocatedBlockProto::kLocsFieldNumber;
const int LocatedBlockProto::kCorruptFieldNumber;
const int LocatedBlockProto::kBlockTokenFieldNumber;
const int LocatedBlockProto::kIsCachedFieldNumber;
const int LocatedBlockProto::kStorageTypesFieldNumber;
const int LocatedBlockProto::kStorageIDsFieldNumber;
#endif  // !_MSC_VER

LocatedBlockProto::LocatedBlockProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LocatedBlockProto::InitAsDefaultInstance() {
  b_ = const_cast< ::hadoop::hdfs::ExtendedBlockProto*>(&::hadoop::hdfs::ExtendedBlockProto::default_instance());
  blocktoken_ = const_cast< ::hadoop::common::TokenProto*>(&::hadoop::common::TokenProto::default_instance());
}

LocatedBlockProto::LocatedBlockProto(const LocatedBlockProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LocatedBlockProto::SharedCtor() {
  _cached_size_ = 0;
  b_ = NULL;
  offset_ = GOOGLE_ULONGLONG(0);
  corrupt_ = false;
  blocktoken_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LocatedBlockProto::~LocatedBlockProto() {
  SharedDtor();
}

void LocatedBlockProto::SharedDtor() {
  if (this != default_instance_) {
    delete b_;
    delete blocktoken_;
  }
}

void LocatedBlockProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LocatedBlockProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LocatedBlockProto_descriptor_;
}

const LocatedBlockProto& LocatedBlockProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

LocatedBlockProto* LocatedBlockProto::default_instance_ = NULL;

LocatedBlockProto* LocatedBlockProto::New() const {
  return new LocatedBlockProto;
}

void LocatedBlockProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_b()) {
      if (b_ != NULL) b_->::hadoop::hdfs::ExtendedBlockProto::Clear();
    }
    offset_ = GOOGLE_ULONGLONG(0);
    corrupt_ = false;
    if (has_blocktoken()) {
      if (blocktoken_ != NULL) blocktoken_->::hadoop::common::TokenProto::Clear();
    }
  }
  locs_.Clear();
  iscached_.Clear();
  storagetypes_.Clear();
  storageids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LocatedBlockProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hadoop.hdfs.ExtendedBlockProto b = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_b()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_offset;
        break;
      }

      // required uint64 offset = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_offset:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_locs;
        break;
      }

      // repeated .hadoop.hdfs.DatanodeInfoProto locs = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_locs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_locs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_locs;
        if (input->ExpectTag(32)) goto parse_corrupt;
        break;
      }

      // required bool corrupt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_corrupt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &corrupt_)));
          set_has_corrupt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_blockToken;
        break;
      }

      // required .hadoop.common.TokenProto blockToken = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_blockToken:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_blocktoken()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_isCached;
        break;
      }

      // repeated bool isCached = 6 [packed = true];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_isCached:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_iscached())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 50, input, this->mutable_iscached())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_storageTypes;
        break;
      }

      // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_storageTypes:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hadoop::hdfs::StorageTypeProto_IsValid(value)) {
            add_storagetypes(static_cast< ::hadoop::hdfs::StorageTypeProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::hadoop::hdfs::StorageTypeProto_IsValid,
                 this->mutable_storagetypes())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_storageTypes;
        if (input->ExpectTag(66)) goto parse_storageIDs;
        break;
      }

      // repeated string storageIDs = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_storageIDs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_storageids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->storageids(this->storageids_size() - 1).data(),
            this->storageids(this->storageids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_storageIDs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LocatedBlockProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hadoop.hdfs.ExtendedBlockProto b = 1;
  if (has_b()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->b(), output);
  }

  // required uint64 offset = 2;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->offset(), output);
  }

  // repeated .hadoop.hdfs.DatanodeInfoProto locs = 3;
  for (int i = 0; i < this->locs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->locs(i), output);
  }

  // required bool corrupt = 4;
  if (has_corrupt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->corrupt(), output);
  }

  // required .hadoop.common.TokenProto blockToken = 5;
  if (has_blocktoken()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->blocktoken(), output);
  }

  // repeated bool isCached = 6 [packed = true];
  if (this->iscached_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(6, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_iscached_cached_byte_size_);
  }
  for (int i = 0; i < this->iscached_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBoolNoTag(
      this->iscached(i), output);
  }

  // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 7;
  for (int i = 0; i < this->storagetypes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->storagetypes(i), output);
  }

  // repeated string storageIDs = 8;
  for (int i = 0; i < this->storageids_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->storageids(i).data(), this->storageids(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->storageids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LocatedBlockProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hadoop.hdfs.ExtendedBlockProto b = 1;
  if (has_b()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->b(), target);
  }

  // required uint64 offset = 2;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->offset(), target);
  }

  // repeated .hadoop.hdfs.DatanodeInfoProto locs = 3;
  for (int i = 0; i < this->locs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->locs(i), target);
  }

  // required bool corrupt = 4;
  if (has_corrupt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->corrupt(), target);
  }

  // required .hadoop.common.TokenProto blockToken = 5;
  if (has_blocktoken()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->blocktoken(), target);
  }

  // repeated bool isCached = 6 [packed = true];
  if (this->iscached_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      6,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _iscached_cached_byte_size_, target);
  }
  for (int i = 0; i < this->iscached_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolNoTagToArray(this->iscached(i), target);
  }

  // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 7;
  for (int i = 0; i < this->storagetypes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->storagetypes(i), target);
  }

  // repeated string storageIDs = 8;
  for (int i = 0; i < this->storageids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->storageids(i).data(), this->storageids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(8, this->storageids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LocatedBlockProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hadoop.hdfs.ExtendedBlockProto b = 1;
    if (has_b()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->b());
    }

    // required uint64 offset = 2;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->offset());
    }

    // required bool corrupt = 4;
    if (has_corrupt()) {
      total_size += 1 + 1;
    }

    // required .hadoop.common.TokenProto blockToken = 5;
    if (has_blocktoken()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->blocktoken());
    }

  }
  // repeated .hadoop.hdfs.DatanodeInfoProto locs = 3;
  total_size += 1 * this->locs_size();
  for (int i = 0; i < this->locs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->locs(i));
  }

  // repeated bool isCached = 6 [packed = true];
  {
    int data_size = 0;
    data_size = 1 * this->iscached_size();
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _iscached_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  // repeated .hadoop.hdfs.StorageTypeProto storageTypes = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->storagetypes_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->storagetypes(i));
    }
    total_size += 1 * this->storagetypes_size() + data_size;
  }

  // repeated string storageIDs = 8;
  total_size += 1 * this->storageids_size();
  for (int i = 0; i < this->storageids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->storageids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LocatedBlockProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LocatedBlockProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LocatedBlockProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LocatedBlockProto::MergeFrom(const LocatedBlockProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  locs_.MergeFrom(from.locs_);
  iscached_.MergeFrom(from.iscached_);
  storagetypes_.MergeFrom(from.storagetypes_);
  storageids_.MergeFrom(from.storageids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_b()) {
      mutable_b()->::hadoop::hdfs::ExtendedBlockProto::MergeFrom(from.b());
    }
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_corrupt()) {
      set_corrupt(from.corrupt());
    }
    if (from.has_blocktoken()) {
      mutable_blocktoken()->::hadoop::common::TokenProto::MergeFrom(from.blocktoken());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LocatedBlockProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LocatedBlockProto::CopyFrom(const LocatedBlockProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatedBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001b) != 0x0000001b) return false;

  if (has_b()) {
    if (!this->b().IsInitialized()) return false;
  }
  for (int i = 0; i < locs_size(); i++) {
    if (!this->locs(i).IsInitialized()) return false;
  }
  if (has_blocktoken()) {
    if (!this->blocktoken().IsInitialized()) return false;
  }
  return true;
}

void LocatedBlockProto::Swap(LocatedBlockProto* other) {
  if (other != this) {
    std::swap(b_, other->b_);
    std::swap(offset_, other->offset_);
    locs_.Swap(&other->locs_);
    std::swap(corrupt_, other->corrupt_);
    std::swap(blocktoken_, other->blocktoken_);
    iscached_.Swap(&other->iscached_);
    storagetypes_.Swap(&other->storagetypes_);
    storageids_.Swap(&other->storageids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LocatedBlockProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LocatedBlockProto_descriptor_;
  metadata.reflection = LocatedBlockProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DataEncryptionKeyProto::kKeyIdFieldNumber;
const int DataEncryptionKeyProto::kBlockPoolIdFieldNumber;
const int DataEncryptionKeyProto::kNonceFieldNumber;
const int DataEncryptionKeyProto::kEncryptionKeyFieldNumber;
const int DataEncryptionKeyProto::kExpiryDateFieldNumber;
const int DataEncryptionKeyProto::kEncryptionAlgorithmFieldNumber;
#endif  // !_MSC_VER

DataEncryptionKeyProto::DataEncryptionKeyProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DataEncryptionKeyProto::InitAsDefaultInstance() {
}

DataEncryptionKeyProto::DataEncryptionKeyProto(const DataEncryptionKeyProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DataEncryptionKeyProto::SharedCtor() {
  _cached_size_ = 0;
  keyid_ = 0u;
  blockpoolid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encryptionkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  expirydate_ = GOOGLE_ULONGLONG(0);
  encryptionalgorithm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataEncryptionKeyProto::~DataEncryptionKeyProto() {
  SharedDtor();
}

void DataEncryptionKeyProto::SharedDtor() {
  if (blockpoolid_ != &::google::protobuf::internal::kEmptyString) {
    delete blockpoolid_;
  }
  if (nonce_ != &::google::protobuf::internal::kEmptyString) {
    delete nonce_;
  }
  if (encryptionkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptionkey_;
  }
  if (encryptionalgorithm_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptionalgorithm_;
  }
  if (this != default_instance_) {
  }
}

void DataEncryptionKeyProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataEncryptionKeyProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataEncryptionKeyProto_descriptor_;
}

const DataEncryptionKeyProto& DataEncryptionKeyProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

DataEncryptionKeyProto* DataEncryptionKeyProto::default_instance_ = NULL;

DataEncryptionKeyProto* DataEncryptionKeyProto::New() const {
  return new DataEncryptionKeyProto;
}

void DataEncryptionKeyProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    keyid_ = 0u;
    if (has_blockpoolid()) {
      if (blockpoolid_ != &::google::protobuf::internal::kEmptyString) {
        blockpoolid_->clear();
      }
    }
    if (has_nonce()) {
      if (nonce_ != &::google::protobuf::internal::kEmptyString) {
        nonce_->clear();
      }
    }
    if (has_encryptionkey()) {
      if (encryptionkey_ != &::google::protobuf::internal::kEmptyString) {
        encryptionkey_->clear();
      }
    }
    expirydate_ = GOOGLE_ULONGLONG(0);
    if (has_encryptionalgorithm()) {
      if (encryptionalgorithm_ != &::google::protobuf::internal::kEmptyString) {
        encryptionalgorithm_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataEncryptionKeyProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 keyId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &keyid_)));
          set_has_keyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_blockPoolId;
        break;
      }

      // required string blockPoolId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_blockPoolId:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_blockpoolid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->blockpoolid().data(), this->blockpoolid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_nonce;
        break;
      }

      // required bytes nonce = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_encryptionKey;
        break;
      }

      // required bytes encryptionKey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encryptionKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encryptionkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_expiryDate;
        break;
      }

      // required uint64 expiryDate = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_expiryDate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &expirydate_)));
          set_has_expirydate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_encryptionAlgorithm;
        break;
      }

      // optional string encryptionAlgorithm = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encryptionAlgorithm:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_encryptionalgorithm()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->encryptionalgorithm().data(), this->encryptionalgorithm().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataEncryptionKeyProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 keyId = 1;
  if (has_keyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->keyid(), output);
  }

  // required string blockPoolId = 2;
  if (has_blockpoolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->blockpoolid().data(), this->blockpoolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->blockpoolid(), output);
  }

  // required bytes nonce = 3;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->nonce(), output);
  }

  // required bytes encryptionKey = 4;
  if (has_encryptionkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->encryptionkey(), output);
  }

  // required uint64 expiryDate = 5;
  if (has_expirydate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->expirydate(), output);
  }

  // optional string encryptionAlgorithm = 6;
  if (has_encryptionalgorithm()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->encryptionalgorithm().data(), this->encryptionalgorithm().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->encryptionalgorithm(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataEncryptionKeyProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 keyId = 1;
  if (has_keyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->keyid(), target);
  }

  // required string blockPoolId = 2;
  if (has_blockpoolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->blockpoolid().data(), this->blockpoolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->blockpoolid(), target);
  }

  // required bytes nonce = 3;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->nonce(), target);
  }

  // required bytes encryptionKey = 4;
  if (has_encryptionkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->encryptionkey(), target);
  }

  // required uint64 expiryDate = 5;
  if (has_expirydate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->expirydate(), target);
  }

  // optional string encryptionAlgorithm = 6;
  if (has_encryptionalgorithm()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->encryptionalgorithm().data(), this->encryptionalgorithm().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->encryptionalgorithm(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataEncryptionKeyProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 keyId = 1;
    if (has_keyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->keyid());
    }

    // required string blockPoolId = 2;
    if (has_blockpoolid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->blockpoolid());
    }

    // required bytes nonce = 3;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // required bytes encryptionKey = 4;
    if (has_encryptionkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encryptionkey());
    }

    // required uint64 expiryDate = 5;
    if (has_expirydate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->expirydate());
    }

    // optional string encryptionAlgorithm = 6;
    if (has_encryptionalgorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->encryptionalgorithm());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataEncryptionKeyProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataEncryptionKeyProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataEncryptionKeyProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataEncryptionKeyProto::MergeFrom(const DataEncryptionKeyProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keyid()) {
      set_keyid(from.keyid());
    }
    if (from.has_blockpoolid()) {
      set_blockpoolid(from.blockpoolid());
    }
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
    if (from.has_encryptionkey()) {
      set_encryptionkey(from.encryptionkey());
    }
    if (from.has_expirydate()) {
      set_expirydate(from.expirydate());
    }
    if (from.has_encryptionalgorithm()) {
      set_encryptionalgorithm(from.encryptionalgorithm());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataEncryptionKeyProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataEncryptionKeyProto::CopyFrom(const DataEncryptionKeyProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataEncryptionKeyProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void DataEncryptionKeyProto::Swap(DataEncryptionKeyProto* other) {
  if (other != this) {
    std::swap(keyid_, other->keyid_);
    std::swap(blockpoolid_, other->blockpoolid_);
    std::swap(nonce_, other->nonce_);
    std::swap(encryptionkey_, other->encryptionkey_);
    std::swap(expirydate_, other->expirydate_);
    std::swap(encryptionalgorithm_, other->encryptionalgorithm_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DataEncryptionKeyProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataEncryptionKeyProto_descriptor_;
  metadata.reflection = DataEncryptionKeyProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LocatedBlocksProto::kFileLengthFieldNumber;
const int LocatedBlocksProto::kBlocksFieldNumber;
const int LocatedBlocksProto::kUnderConstructionFieldNumber;
const int LocatedBlocksProto::kLastBlockFieldNumber;
const int LocatedBlocksProto::kIsLastBlockCompleteFieldNumber;
#endif  // !_MSC_VER

LocatedBlocksProto::LocatedBlocksProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LocatedBlocksProto::InitAsDefaultInstance() {
  lastblock_ = const_cast< ::hadoop::hdfs::LocatedBlockProto*>(&::hadoop::hdfs::LocatedBlockProto::default_instance());
}

LocatedBlocksProto::LocatedBlocksProto(const LocatedBlocksProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LocatedBlocksProto::SharedCtor() {
  _cached_size_ = 0;
  filelength_ = GOOGLE_ULONGLONG(0);
  underconstruction_ = false;
  lastblock_ = NULL;
  islastblockcomplete_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LocatedBlocksProto::~LocatedBlocksProto() {
  SharedDtor();
}

void LocatedBlocksProto::SharedDtor() {
  if (this != default_instance_) {
    delete lastblock_;
  }
}

void LocatedBlocksProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LocatedBlocksProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LocatedBlocksProto_descriptor_;
}

const LocatedBlocksProto& LocatedBlocksProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

LocatedBlocksProto* LocatedBlocksProto::default_instance_ = NULL;

LocatedBlocksProto* LocatedBlocksProto::New() const {
  return new LocatedBlocksProto;
}

void LocatedBlocksProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    filelength_ = GOOGLE_ULONGLONG(0);
    underconstruction_ = false;
    if (has_lastblock()) {
      if (lastblock_ != NULL) lastblock_->::hadoop::hdfs::LocatedBlockProto::Clear();
    }
    islastblockcomplete_ = false;
  }
  blocks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LocatedBlocksProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 fileLength = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &filelength_)));
          set_has_filelength();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_blocks;
        break;
      }

      // repeated .hadoop.hdfs.LocatedBlockProto blocks = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_blocks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_blocks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_blocks;
        if (input->ExpectTag(24)) goto parse_underConstruction;
        break;
      }

      // required bool underConstruction = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_underConstruction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &underconstruction_)));
          set_has_underconstruction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_lastBlock;
        break;
      }

      // optional .hadoop.hdfs.LocatedBlockProto lastBlock = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lastBlock:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lastblock()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_isLastBlockComplete;
        break;
      }

      // required bool isLastBlockComplete = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isLastBlockComplete:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &islastblockcomplete_)));
          set_has_islastblockcomplete();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LocatedBlocksProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 fileLength = 1;
  if (has_filelength()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->filelength(), output);
  }

  // repeated .hadoop.hdfs.LocatedBlockProto blocks = 2;
  for (int i = 0; i < this->blocks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->blocks(i), output);
  }

  // required bool underConstruction = 3;
  if (has_underconstruction()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->underconstruction(), output);
  }

  // optional .hadoop.hdfs.LocatedBlockProto lastBlock = 4;
  if (has_lastblock()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->lastblock(), output);
  }

  // required bool isLastBlockComplete = 5;
  if (has_islastblockcomplete()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->islastblockcomplete(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LocatedBlocksProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 fileLength = 1;
  if (has_filelength()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->filelength(), target);
  }

  // repeated .hadoop.hdfs.LocatedBlockProto blocks = 2;
  for (int i = 0; i < this->blocks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->blocks(i), target);
  }

  // required bool underConstruction = 3;
  if (has_underconstruction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->underconstruction(), target);
  }

  // optional .hadoop.hdfs.LocatedBlockProto lastBlock = 4;
  if (has_lastblock()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->lastblock(), target);
  }

  // required bool isLastBlockComplete = 5;
  if (has_islastblockcomplete()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->islastblockcomplete(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LocatedBlocksProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 fileLength = 1;
    if (has_filelength()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->filelength());
    }

    // required bool underConstruction = 3;
    if (has_underconstruction()) {
      total_size += 1 + 1;
    }

    // optional .hadoop.hdfs.LocatedBlockProto lastBlock = 4;
    if (has_lastblock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lastblock());
    }

    // required bool isLastBlockComplete = 5;
    if (has_islastblockcomplete()) {
      total_size += 1 + 1;
    }

  }
  // repeated .hadoop.hdfs.LocatedBlockProto blocks = 2;
  total_size += 1 * this->blocks_size();
  for (int i = 0; i < this->blocks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->blocks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LocatedBlocksProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LocatedBlocksProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LocatedBlocksProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LocatedBlocksProto::MergeFrom(const LocatedBlocksProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  blocks_.MergeFrom(from.blocks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filelength()) {
      set_filelength(from.filelength());
    }
    if (from.has_underconstruction()) {
      set_underconstruction(from.underconstruction());
    }
    if (from.has_lastblock()) {
      mutable_lastblock()->::hadoop::hdfs::LocatedBlockProto::MergeFrom(from.lastblock());
    }
    if (from.has_islastblockcomplete()) {
      set_islastblockcomplete(from.islastblockcomplete());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LocatedBlocksProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LocatedBlocksProto::CopyFrom(const LocatedBlocksProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatedBlocksProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000015) != 0x00000015) return false;

  for (int i = 0; i < blocks_size(); i++) {
    if (!this->blocks(i).IsInitialized()) return false;
  }
  if (has_lastblock()) {
    if (!this->lastblock().IsInitialized()) return false;
  }
  return true;
}

void LocatedBlocksProto::Swap(LocatedBlocksProto* other) {
  if (other != this) {
    std::swap(filelength_, other->filelength_);
    blocks_.Swap(&other->blocks_);
    std::swap(underconstruction_, other->underconstruction_);
    std::swap(lastblock_, other->lastblock_);
    std::swap(islastblockcomplete_, other->islastblockcomplete_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LocatedBlocksProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LocatedBlocksProto_descriptor_;
  metadata.reflection = LocatedBlocksProto_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* HdfsFileStatusProto_FileType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HdfsFileStatusProto_FileType_descriptor_;
}
bool HdfsFileStatusProto_FileType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const HdfsFileStatusProto_FileType HdfsFileStatusProto::IS_DIR;
const HdfsFileStatusProto_FileType HdfsFileStatusProto::IS_FILE;
const HdfsFileStatusProto_FileType HdfsFileStatusProto::IS_SYMLINK;
const HdfsFileStatusProto_FileType HdfsFileStatusProto::FileType_MIN;
const HdfsFileStatusProto_FileType HdfsFileStatusProto::FileType_MAX;
const int HdfsFileStatusProto::FileType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int HdfsFileStatusProto::kFileTypeFieldNumber;
const int HdfsFileStatusProto::kPathFieldNumber;
const int HdfsFileStatusProto::kLengthFieldNumber;
const int HdfsFileStatusProto::kPermissionFieldNumber;
const int HdfsFileStatusProto::kOwnerFieldNumber;
const int HdfsFileStatusProto::kGroupFieldNumber;
const int HdfsFileStatusProto::kModificationTimeFieldNumber;
const int HdfsFileStatusProto::kAccessTimeFieldNumber;
const int HdfsFileStatusProto::kSymlinkFieldNumber;
const int HdfsFileStatusProto::kBlockReplicationFieldNumber;
const int HdfsFileStatusProto::kBlocksizeFieldNumber;
const int HdfsFileStatusProto::kLocationsFieldNumber;
const int HdfsFileStatusProto::kFileIdFieldNumber;
const int HdfsFileStatusProto::kChildrenNumFieldNumber;
#endif  // !_MSC_VER

HdfsFileStatusProto::HdfsFileStatusProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HdfsFileStatusProto::InitAsDefaultInstance() {
  permission_ = const_cast< ::hadoop::hdfs::FsPermissionProto*>(&::hadoop::hdfs::FsPermissionProto::default_instance());
  locations_ = const_cast< ::hadoop::hdfs::LocatedBlocksProto*>(&::hadoop::hdfs::LocatedBlocksProto::default_instance());
}

HdfsFileStatusProto::HdfsFileStatusProto(const HdfsFileStatusProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HdfsFileStatusProto::SharedCtor() {
  _cached_size_ = 0;
  filetype_ = 1;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  length_ = GOOGLE_ULONGLONG(0);
  permission_ = NULL;
  owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  modification_time_ = GOOGLE_ULONGLONG(0);
  access_time_ = GOOGLE_ULONGLONG(0);
  symlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  block_replication_ = 0u;
  blocksize_ = GOOGLE_ULONGLONG(0);
  locations_ = NULL;
  fileid_ = GOOGLE_ULONGLONG(0);
  childrennum_ = -1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HdfsFileStatusProto::~HdfsFileStatusProto() {
  SharedDtor();
}

void HdfsFileStatusProto::SharedDtor() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_;
  }
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    delete group_;
  }
  if (symlink_ != &::google::protobuf::internal::kEmptyString) {
    delete symlink_;
  }
  if (this != default_instance_) {
    delete permission_;
    delete locations_;
  }
}

void HdfsFileStatusProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HdfsFileStatusProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HdfsFileStatusProto_descriptor_;
}

const HdfsFileStatusProto& HdfsFileStatusProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

HdfsFileStatusProto* HdfsFileStatusProto::default_instance_ = NULL;

HdfsFileStatusProto* HdfsFileStatusProto::New() const {
  return new HdfsFileStatusProto;
}

void HdfsFileStatusProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    filetype_ = 1;
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
    length_ = GOOGLE_ULONGLONG(0);
    if (has_permission()) {
      if (permission_ != NULL) permission_->::hadoop::hdfs::FsPermissionProto::Clear();
    }
    if (has_owner()) {
      if (owner_ != &::google::protobuf::internal::kEmptyString) {
        owner_->clear();
      }
    }
    if (has_group()) {
      if (group_ != &::google::protobuf::internal::kEmptyString) {
        group_->clear();
      }
    }
    modification_time_ = GOOGLE_ULONGLONG(0);
    access_time_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_symlink()) {
      if (symlink_ != &::google::protobuf::internal::kEmptyString) {
        symlink_->clear();
      }
    }
    block_replication_ = 0u;
    blocksize_ = GOOGLE_ULONGLONG(0);
    if (has_locations()) {
      if (locations_ != NULL) locations_->::hadoop::hdfs::LocatedBlocksProto::Clear();
    }
    fileid_ = GOOGLE_ULONGLONG(0);
    childrennum_ = -1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HdfsFileStatusProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hadoop.hdfs.HdfsFileStatusProto.FileType fileType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hadoop::hdfs::HdfsFileStatusProto_FileType_IsValid(value)) {
            set_filetype(static_cast< ::hadoop::hdfs::HdfsFileStatusProto_FileType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // required bytes path = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_length;
        break;
      }

      // required uint64 length = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_permission;
        break;
      }

      // required .hadoop.hdfs.FsPermissionProto permission = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_permission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_owner;
        break;
      }

      // required string owner = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_owner:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_owner()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->owner().data(), this->owner().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_group;
        break;
      }

      // required string group = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->group().data(), this->group().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_modification_time;
        break;
      }

      // required uint64 modification_time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_modification_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &modification_time_)));
          set_has_modification_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_access_time;
        break;
      }

      // required uint64 access_time = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_access_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &access_time_)));
          set_has_access_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_symlink;
        break;
      }

      // optional bytes symlink = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_symlink:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_symlink()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_block_replication;
        break;
      }

      // optional uint32 block_replication = 10 [default = 0];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_block_replication:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &block_replication_)));
          set_has_block_replication();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_blocksize;
        break;
      }

      // optional uint64 blocksize = 11 [default = 0];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blocksize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blocksize_)));
          set_has_blocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_locations;
        break;
      }

      // optional .hadoop.hdfs.LocatedBlocksProto locations = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_locations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_locations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_fileId;
        break;
      }

      // optional uint64 fileId = 13 [default = 0];
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fileId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &fileid_)));
          set_has_fileid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_childrenNum;
        break;
      }

      // optional int32 childrenNum = 14 [default = -1];
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_childrenNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &childrennum_)));
          set_has_childrennum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HdfsFileStatusProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hadoop.hdfs.HdfsFileStatusProto.FileType fileType = 1;
  if (has_filetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->filetype(), output);
  }

  // required bytes path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->path(), output);
  }

  // required uint64 length = 3;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->length(), output);
  }

  // required .hadoop.hdfs.FsPermissionProto permission = 4;
  if (has_permission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->permission(), output);
  }

  // required string owner = 5;
  if (has_owner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->owner().data(), this->owner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->owner(), output);
  }

  // required string group = 6;
  if (has_group()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->group().data(), this->group().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->group(), output);
  }

  // required uint64 modification_time = 7;
  if (has_modification_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->modification_time(), output);
  }

  // required uint64 access_time = 8;
  if (has_access_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->access_time(), output);
  }

  // optional bytes symlink = 9;
  if (has_symlink()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      9, this->symlink(), output);
  }

  // optional uint32 block_replication = 10 [default = 0];
  if (has_block_replication()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->block_replication(), output);
  }

  // optional uint64 blocksize = 11 [default = 0];
  if (has_blocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->blocksize(), output);
  }

  // optional .hadoop.hdfs.LocatedBlocksProto locations = 12;
  if (has_locations()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->locations(), output);
  }

  // optional uint64 fileId = 13 [default = 0];
  if (has_fileid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->fileid(), output);
  }

  // optional int32 childrenNum = 14 [default = -1];
  if (has_childrennum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->childrennum(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HdfsFileStatusProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hadoop.hdfs.HdfsFileStatusProto.FileType fileType = 1;
  if (has_filetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->filetype(), target);
  }

  // required bytes path = 2;
  if (has_path()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->path(), target);
  }

  // required uint64 length = 3;
  if (has_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->length(), target);
  }

  // required .hadoop.hdfs.FsPermissionProto permission = 4;
  if (has_permission()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->permission(), target);
  }

  // required string owner = 5;
  if (has_owner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->owner().data(), this->owner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->owner(), target);
  }

  // required string group = 6;
  if (has_group()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->group().data(), this->group().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->group(), target);
  }

  // required uint64 modification_time = 7;
  if (has_modification_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->modification_time(), target);
  }

  // required uint64 access_time = 8;
  if (has_access_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->access_time(), target);
  }

  // optional bytes symlink = 9;
  if (has_symlink()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        9, this->symlink(), target);
  }

  // optional uint32 block_replication = 10 [default = 0];
  if (has_block_replication()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->block_replication(), target);
  }

  // optional uint64 blocksize = 11 [default = 0];
  if (has_blocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->blocksize(), target);
  }

  // optional .hadoop.hdfs.LocatedBlocksProto locations = 12;
  if (has_locations()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->locations(), target);
  }

  // optional uint64 fileId = 13 [default = 0];
  if (has_fileid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(13, this->fileid(), target);
  }

  // optional int32 childrenNum = 14 [default = -1];
  if (has_childrennum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->childrennum(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HdfsFileStatusProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hadoop.hdfs.HdfsFileStatusProto.FileType fileType = 1;
    if (has_filetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->filetype());
    }

    // required bytes path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->path());
    }

    // required uint64 length = 3;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->length());
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 4;
    if (has_permission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->permission());
    }

    // required string owner = 5;
    if (has_owner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->owner());
    }

    // required string group = 6;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group());
    }

    // required uint64 modification_time = 7;
    if (has_modification_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->modification_time());
    }

    // required uint64 access_time = 8;
    if (has_access_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->access_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes symlink = 9;
    if (has_symlink()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->symlink());
    }

    // optional uint32 block_replication = 10 [default = 0];
    if (has_block_replication()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->block_replication());
    }

    // optional uint64 blocksize = 11 [default = 0];
    if (has_blocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blocksize());
    }

    // optional .hadoop.hdfs.LocatedBlocksProto locations = 12;
    if (has_locations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->locations());
    }

    // optional uint64 fileId = 13 [default = 0];
    if (has_fileid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->fileid());
    }

    // optional int32 childrenNum = 14 [default = -1];
    if (has_childrennum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->childrennum());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HdfsFileStatusProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HdfsFileStatusProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HdfsFileStatusProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HdfsFileStatusProto::MergeFrom(const HdfsFileStatusProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filetype()) {
      set_filetype(from.filetype());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_permission()) {
      mutable_permission()->::hadoop::hdfs::FsPermissionProto::MergeFrom(from.permission());
    }
    if (from.has_owner()) {
      set_owner(from.owner());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_modification_time()) {
      set_modification_time(from.modification_time());
    }
    if (from.has_access_time()) {
      set_access_time(from.access_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_symlink()) {
      set_symlink(from.symlink());
    }
    if (from.has_block_replication()) {
      set_block_replication(from.block_replication());
    }
    if (from.has_blocksize()) {
      set_blocksize(from.blocksize());
    }
    if (from.has_locations()) {
      mutable_locations()->::hadoop::hdfs::LocatedBlocksProto::MergeFrom(from.locations());
    }
    if (from.has_fileid()) {
      set_fileid(from.fileid());
    }
    if (from.has_childrennum()) {
      set_childrennum(from.childrennum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HdfsFileStatusProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HdfsFileStatusProto::CopyFrom(const HdfsFileStatusProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HdfsFileStatusProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_permission()) {
    if (!this->permission().IsInitialized()) return false;
  }
  if (has_locations()) {
    if (!this->locations().IsInitialized()) return false;
  }
  return true;
}

void HdfsFileStatusProto::Swap(HdfsFileStatusProto* other) {
  if (other != this) {
    std::swap(filetype_, other->filetype_);
    std::swap(path_, other->path_);
    std::swap(length_, other->length_);
    std::swap(permission_, other->permission_);
    std::swap(owner_, other->owner_);
    std::swap(group_, other->group_);
    std::swap(modification_time_, other->modification_time_);
    std::swap(access_time_, other->access_time_);
    std::swap(symlink_, other->symlink_);
    std::swap(block_replication_, other->block_replication_);
    std::swap(blocksize_, other->blocksize_);
    std::swap(locations_, other->locations_);
    std::swap(fileid_, other->fileid_);
    std::swap(childrennum_, other->childrennum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HdfsFileStatusProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HdfsFileStatusProto_descriptor_;
  metadata.reflection = HdfsFileStatusProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FsServerDefaultsProto::kBlockSizeFieldNumber;
const int FsServerDefaultsProto::kBytesPerChecksumFieldNumber;
const int FsServerDefaultsProto::kWritePacketSizeFieldNumber;
const int FsServerDefaultsProto::kReplicationFieldNumber;
const int FsServerDefaultsProto::kFileBufferSizeFieldNumber;
const int FsServerDefaultsProto::kEncryptDataTransferFieldNumber;
const int FsServerDefaultsProto::kTrashIntervalFieldNumber;
const int FsServerDefaultsProto::kChecksumTypeFieldNumber;
#endif  // !_MSC_VER

FsServerDefaultsProto::FsServerDefaultsProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FsServerDefaultsProto::InitAsDefaultInstance() {
}

FsServerDefaultsProto::FsServerDefaultsProto(const FsServerDefaultsProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FsServerDefaultsProto::SharedCtor() {
  _cached_size_ = 0;
  blocksize_ = GOOGLE_ULONGLONG(0);
  bytesperchecksum_ = 0u;
  writepacketsize_ = 0u;
  replication_ = 0u;
  filebuffersize_ = 0u;
  encryptdatatransfer_ = false;
  trashinterval_ = GOOGLE_ULONGLONG(0);
  checksumtype_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FsServerDefaultsProto::~FsServerDefaultsProto() {
  SharedDtor();
}

void FsServerDefaultsProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FsServerDefaultsProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FsServerDefaultsProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FsServerDefaultsProto_descriptor_;
}

const FsServerDefaultsProto& FsServerDefaultsProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

FsServerDefaultsProto* FsServerDefaultsProto::default_instance_ = NULL;

FsServerDefaultsProto* FsServerDefaultsProto::New() const {
  return new FsServerDefaultsProto;
}

void FsServerDefaultsProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    blocksize_ = GOOGLE_ULONGLONG(0);
    bytesperchecksum_ = 0u;
    writepacketsize_ = 0u;
    replication_ = 0u;
    filebuffersize_ = 0u;
    encryptdatatransfer_ = false;
    trashinterval_ = GOOGLE_ULONGLONG(0);
    checksumtype_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FsServerDefaultsProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 blockSize = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blocksize_)));
          set_has_blocksize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_bytesPerChecksum;
        break;
      }

      // required uint32 bytesPerChecksum = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bytesPerChecksum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bytesperchecksum_)));
          set_has_bytesperchecksum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_writePacketSize;
        break;
      }

      // required uint32 writePacketSize = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_writePacketSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &writepacketsize_)));
          set_has_writepacketsize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_replication;
        break;
      }

      // required uint32 replication = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_replication:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &replication_)));
          set_has_replication();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_fileBufferSize;
        break;
      }

      // required uint32 fileBufferSize = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fileBufferSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &filebuffersize_)));
          set_has_filebuffersize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_encryptDataTransfer;
        break;
      }

      // optional bool encryptDataTransfer = 6 [default = false];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encryptDataTransfer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &encryptdatatransfer_)));
          set_has_encryptdatatransfer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_trashInterval;
        break;
      }

      // optional uint64 trashInterval = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_trashInterval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &trashinterval_)));
          set_has_trashinterval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_checksumType;
        break;
      }

      // optional .hadoop.hdfs.ChecksumTypeProto checksumType = 8 [default = CHECKSUM_CRC32];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checksumType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hadoop::hdfs::ChecksumTypeProto_IsValid(value)) {
            set_checksumtype(static_cast< ::hadoop::hdfs::ChecksumTypeProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FsServerDefaultsProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 blockSize = 1;
  if (has_blocksize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->blocksize(), output);
  }

  // required uint32 bytesPerChecksum = 2;
  if (has_bytesperchecksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bytesperchecksum(), output);
  }

  // required uint32 writePacketSize = 3;
  if (has_writepacketsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->writepacketsize(), output);
  }

  // required uint32 replication = 4;
  if (has_replication()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->replication(), output);
  }

  // required uint32 fileBufferSize = 5;
  if (has_filebuffersize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->filebuffersize(), output);
  }

  // optional bool encryptDataTransfer = 6 [default = false];
  if (has_encryptdatatransfer()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->encryptdatatransfer(), output);
  }

  // optional uint64 trashInterval = 7 [default = 0];
  if (has_trashinterval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->trashinterval(), output);
  }

  // optional .hadoop.hdfs.ChecksumTypeProto checksumType = 8 [default = CHECKSUM_CRC32];
  if (has_checksumtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->checksumtype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FsServerDefaultsProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 blockSize = 1;
  if (has_blocksize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->blocksize(), target);
  }

  // required uint32 bytesPerChecksum = 2;
  if (has_bytesperchecksum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->bytesperchecksum(), target);
  }

  // required uint32 writePacketSize = 3;
  if (has_writepacketsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->writepacketsize(), target);
  }

  // required uint32 replication = 4;
  if (has_replication()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->replication(), target);
  }

  // required uint32 fileBufferSize = 5;
  if (has_filebuffersize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->filebuffersize(), target);
  }

  // optional bool encryptDataTransfer = 6 [default = false];
  if (has_encryptdatatransfer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->encryptdatatransfer(), target);
  }

  // optional uint64 trashInterval = 7 [default = 0];
  if (has_trashinterval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->trashinterval(), target);
  }

  // optional .hadoop.hdfs.ChecksumTypeProto checksumType = 8 [default = CHECKSUM_CRC32];
  if (has_checksumtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->checksumtype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FsServerDefaultsProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 blockSize = 1;
    if (has_blocksize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blocksize());
    }

    // required uint32 bytesPerChecksum = 2;
    if (has_bytesperchecksum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bytesperchecksum());
    }

    // required uint32 writePacketSize = 3;
    if (has_writepacketsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->writepacketsize());
    }

    // required uint32 replication = 4;
    if (has_replication()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->replication());
    }

    // required uint32 fileBufferSize = 5;
    if (has_filebuffersize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->filebuffersize());
    }

    // optional bool encryptDataTransfer = 6 [default = false];
    if (has_encryptdatatransfer()) {
      total_size += 1 + 1;
    }

    // optional uint64 trashInterval = 7 [default = 0];
    if (has_trashinterval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->trashinterval());
    }

    // optional .hadoop.hdfs.ChecksumTypeProto checksumType = 8 [default = CHECKSUM_CRC32];
    if (has_checksumtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->checksumtype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FsServerDefaultsProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FsServerDefaultsProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FsServerDefaultsProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FsServerDefaultsProto::MergeFrom(const FsServerDefaultsProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_blocksize()) {
      set_blocksize(from.blocksize());
    }
    if (from.has_bytesperchecksum()) {
      set_bytesperchecksum(from.bytesperchecksum());
    }
    if (from.has_writepacketsize()) {
      set_writepacketsize(from.writepacketsize());
    }
    if (from.has_replication()) {
      set_replication(from.replication());
    }
    if (from.has_filebuffersize()) {
      set_filebuffersize(from.filebuffersize());
    }
    if (from.has_encryptdatatransfer()) {
      set_encryptdatatransfer(from.encryptdatatransfer());
    }
    if (from.has_trashinterval()) {
      set_trashinterval(from.trashinterval());
    }
    if (from.has_checksumtype()) {
      set_checksumtype(from.checksumtype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FsServerDefaultsProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FsServerDefaultsProto::CopyFrom(const FsServerDefaultsProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FsServerDefaultsProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void FsServerDefaultsProto::Swap(FsServerDefaultsProto* other) {
  if (other != this) {
    std::swap(blocksize_, other->blocksize_);
    std::swap(bytesperchecksum_, other->bytesperchecksum_);
    std::swap(writepacketsize_, other->writepacketsize_);
    std::swap(replication_, other->replication_);
    std::swap(filebuffersize_, other->filebuffersize_);
    std::swap(encryptdatatransfer_, other->encryptdatatransfer_);
    std::swap(trashinterval_, other->trashinterval_);
    std::swap(checksumtype_, other->checksumtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FsServerDefaultsProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FsServerDefaultsProto_descriptor_;
  metadata.reflection = FsServerDefaultsProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DirectoryListingProto::kPartialListingFieldNumber;
const int DirectoryListingProto::kRemainingEntriesFieldNumber;
#endif  // !_MSC_VER

DirectoryListingProto::DirectoryListingProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DirectoryListingProto::InitAsDefaultInstance() {
}

DirectoryListingProto::DirectoryListingProto(const DirectoryListingProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DirectoryListingProto::SharedCtor() {
  _cached_size_ = 0;
  remainingentries_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectoryListingProto::~DirectoryListingProto() {
  SharedDtor();
}

void DirectoryListingProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DirectoryListingProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DirectoryListingProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DirectoryListingProto_descriptor_;
}

const DirectoryListingProto& DirectoryListingProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

DirectoryListingProto* DirectoryListingProto::default_instance_ = NULL;

DirectoryListingProto* DirectoryListingProto::New() const {
  return new DirectoryListingProto;
}

void DirectoryListingProto::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    remainingentries_ = 0u;
  }
  partiallisting_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DirectoryListingProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hadoop.hdfs.HdfsFileStatusProto partialListing = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_partialListing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_partiallisting()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_partialListing;
        if (input->ExpectTag(16)) goto parse_remainingEntries;
        break;
      }

      // required uint32 remainingEntries = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_remainingEntries:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remainingentries_)));
          set_has_remainingentries();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectoryListingProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hadoop.hdfs.HdfsFileStatusProto partialListing = 1;
  for (int i = 0; i < this->partiallisting_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->partiallisting(i), output);
  }

  // required uint32 remainingEntries = 2;
  if (has_remainingentries()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->remainingentries(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DirectoryListingProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hadoop.hdfs.HdfsFileStatusProto partialListing = 1;
  for (int i = 0; i < this->partiallisting_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->partiallisting(i), target);
  }

  // required uint32 remainingEntries = 2;
  if (has_remainingentries()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->remainingentries(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DirectoryListingProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 remainingEntries = 2;
    if (has_remainingentries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remainingentries());
    }

  }
  // repeated .hadoop.hdfs.HdfsFileStatusProto partialListing = 1;
  total_size += 1 * this->partiallisting_size();
  for (int i = 0; i < this->partiallisting_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->partiallisting(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectoryListingProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DirectoryListingProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DirectoryListingProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DirectoryListingProto::MergeFrom(const DirectoryListingProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  partiallisting_.MergeFrom(from.partiallisting_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_remainingentries()) {
      set_remainingentries(from.remainingentries());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DirectoryListingProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DirectoryListingProto::CopyFrom(const DirectoryListingProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectoryListingProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  for (int i = 0; i < partiallisting_size(); i++) {
    if (!this->partiallisting(i).IsInitialized()) return false;
  }
  return true;
}

void DirectoryListingProto::Swap(DirectoryListingProto* other) {
  if (other != this) {
    partiallisting_.Swap(&other->partiallisting_);
    std::swap(remainingentries_, other->remainingentries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DirectoryListingProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DirectoryListingProto_descriptor_;
  metadata.reflection = DirectoryListingProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SnapshottableDirectoryStatusProto::kDirStatusFieldNumber;
const int SnapshottableDirectoryStatusProto::kSnapshotQuotaFieldNumber;
const int SnapshottableDirectoryStatusProto::kSnapshotNumberFieldNumber;
const int SnapshottableDirectoryStatusProto::kParentFullpathFieldNumber;
#endif  // !_MSC_VER

SnapshottableDirectoryStatusProto::SnapshottableDirectoryStatusProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SnapshottableDirectoryStatusProto::InitAsDefaultInstance() {
  dirstatus_ = const_cast< ::hadoop::hdfs::HdfsFileStatusProto*>(&::hadoop::hdfs::HdfsFileStatusProto::default_instance());
}

SnapshottableDirectoryStatusProto::SnapshottableDirectoryStatusProto(const SnapshottableDirectoryStatusProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SnapshottableDirectoryStatusProto::SharedCtor() {
  _cached_size_ = 0;
  dirstatus_ = NULL;
  snapshot_quota_ = 0u;
  snapshot_number_ = 0u;
  parent_fullpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SnapshottableDirectoryStatusProto::~SnapshottableDirectoryStatusProto() {
  SharedDtor();
}

void SnapshottableDirectoryStatusProto::SharedDtor() {
  if (parent_fullpath_ != &::google::protobuf::internal::kEmptyString) {
    delete parent_fullpath_;
  }
  if (this != default_instance_) {
    delete dirstatus_;
  }
}

void SnapshottableDirectoryStatusProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SnapshottableDirectoryStatusProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SnapshottableDirectoryStatusProto_descriptor_;
}

const SnapshottableDirectoryStatusProto& SnapshottableDirectoryStatusProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

SnapshottableDirectoryStatusProto* SnapshottableDirectoryStatusProto::default_instance_ = NULL;

SnapshottableDirectoryStatusProto* SnapshottableDirectoryStatusProto::New() const {
  return new SnapshottableDirectoryStatusProto;
}

void SnapshottableDirectoryStatusProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_dirstatus()) {
      if (dirstatus_ != NULL) dirstatus_->::hadoop::hdfs::HdfsFileStatusProto::Clear();
    }
    snapshot_quota_ = 0u;
    snapshot_number_ = 0u;
    if (has_parent_fullpath()) {
      if (parent_fullpath_ != &::google::protobuf::internal::kEmptyString) {
        parent_fullpath_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SnapshottableDirectoryStatusProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hadoop.hdfs.HdfsFileStatusProto dirStatus = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dirstatus()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_snapshot_quota;
        break;
      }

      // required uint32 snapshot_quota = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_snapshot_quota:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &snapshot_quota_)));
          set_has_snapshot_quota();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_snapshot_number;
        break;
      }

      // required uint32 snapshot_number = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_snapshot_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &snapshot_number_)));
          set_has_snapshot_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_parent_fullpath;
        break;
      }

      // required bytes parent_fullpath = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_parent_fullpath:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_parent_fullpath()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SnapshottableDirectoryStatusProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hadoop.hdfs.HdfsFileStatusProto dirStatus = 1;
  if (has_dirstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->dirstatus(), output);
  }

  // required uint32 snapshot_quota = 2;
  if (has_snapshot_quota()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->snapshot_quota(), output);
  }

  // required uint32 snapshot_number = 3;
  if (has_snapshot_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->snapshot_number(), output);
  }

  // required bytes parent_fullpath = 4;
  if (has_parent_fullpath()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->parent_fullpath(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SnapshottableDirectoryStatusProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hadoop.hdfs.HdfsFileStatusProto dirStatus = 1;
  if (has_dirstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->dirstatus(), target);
  }

  // required uint32 snapshot_quota = 2;
  if (has_snapshot_quota()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->snapshot_quota(), target);
  }

  // required uint32 snapshot_number = 3;
  if (has_snapshot_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->snapshot_number(), target);
  }

  // required bytes parent_fullpath = 4;
  if (has_parent_fullpath()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->parent_fullpath(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SnapshottableDirectoryStatusProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hadoop.hdfs.HdfsFileStatusProto dirStatus = 1;
    if (has_dirstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dirstatus());
    }

    // required uint32 snapshot_quota = 2;
    if (has_snapshot_quota()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->snapshot_quota());
    }

    // required uint32 snapshot_number = 3;
    if (has_snapshot_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->snapshot_number());
    }

    // required bytes parent_fullpath = 4;
    if (has_parent_fullpath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->parent_fullpath());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SnapshottableDirectoryStatusProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SnapshottableDirectoryStatusProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SnapshottableDirectoryStatusProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SnapshottableDirectoryStatusProto::MergeFrom(const SnapshottableDirectoryStatusProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dirstatus()) {
      mutable_dirstatus()->::hadoop::hdfs::HdfsFileStatusProto::MergeFrom(from.dirstatus());
    }
    if (from.has_snapshot_quota()) {
      set_snapshot_quota(from.snapshot_quota());
    }
    if (from.has_snapshot_number()) {
      set_snapshot_number(from.snapshot_number());
    }
    if (from.has_parent_fullpath()) {
      set_parent_fullpath(from.parent_fullpath());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SnapshottableDirectoryStatusProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshottableDirectoryStatusProto::CopyFrom(const SnapshottableDirectoryStatusProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshottableDirectoryStatusProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_dirstatus()) {
    if (!this->dirstatus().IsInitialized()) return false;
  }
  return true;
}

void SnapshottableDirectoryStatusProto::Swap(SnapshottableDirectoryStatusProto* other) {
  if (other != this) {
    std::swap(dirstatus_, other->dirstatus_);
    std::swap(snapshot_quota_, other->snapshot_quota_);
    std::swap(snapshot_number_, other->snapshot_number_);
    std::swap(parent_fullpath_, other->parent_fullpath_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SnapshottableDirectoryStatusProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SnapshottableDirectoryStatusProto_descriptor_;
  metadata.reflection = SnapshottableDirectoryStatusProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SnapshottableDirectoryListingProto::kSnapshottableDirListingFieldNumber;
#endif  // !_MSC_VER

SnapshottableDirectoryListingProto::SnapshottableDirectoryListingProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SnapshottableDirectoryListingProto::InitAsDefaultInstance() {
}

SnapshottableDirectoryListingProto::SnapshottableDirectoryListingProto(const SnapshottableDirectoryListingProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SnapshottableDirectoryListingProto::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SnapshottableDirectoryListingProto::~SnapshottableDirectoryListingProto() {
  SharedDtor();
}

void SnapshottableDirectoryListingProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SnapshottableDirectoryListingProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SnapshottableDirectoryListingProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SnapshottableDirectoryListingProto_descriptor_;
}

const SnapshottableDirectoryListingProto& SnapshottableDirectoryListingProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

SnapshottableDirectoryListingProto* SnapshottableDirectoryListingProto::default_instance_ = NULL;

SnapshottableDirectoryListingProto* SnapshottableDirectoryListingProto::New() const {
  return new SnapshottableDirectoryListingProto;
}

void SnapshottableDirectoryListingProto::Clear() {
  snapshottabledirlisting_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SnapshottableDirectoryListingProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hadoop.hdfs.SnapshottableDirectoryStatusProto snapshottableDirListing = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_snapshottableDirListing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_snapshottabledirlisting()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_snapshottableDirListing;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SnapshottableDirectoryListingProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hadoop.hdfs.SnapshottableDirectoryStatusProto snapshottableDirListing = 1;
  for (int i = 0; i < this->snapshottabledirlisting_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->snapshottabledirlisting(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SnapshottableDirectoryListingProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hadoop.hdfs.SnapshottableDirectoryStatusProto snapshottableDirListing = 1;
  for (int i = 0; i < this->snapshottabledirlisting_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->snapshottabledirlisting(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SnapshottableDirectoryListingProto::ByteSize() const {
  int total_size = 0;

  // repeated .hadoop.hdfs.SnapshottableDirectoryStatusProto snapshottableDirListing = 1;
  total_size += 1 * this->snapshottabledirlisting_size();
  for (int i = 0; i < this->snapshottabledirlisting_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->snapshottabledirlisting(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SnapshottableDirectoryListingProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SnapshottableDirectoryListingProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SnapshottableDirectoryListingProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SnapshottableDirectoryListingProto::MergeFrom(const SnapshottableDirectoryListingProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  snapshottabledirlisting_.MergeFrom(from.snapshottabledirlisting_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SnapshottableDirectoryListingProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshottableDirectoryListingProto::CopyFrom(const SnapshottableDirectoryListingProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshottableDirectoryListingProto::IsInitialized() const {

  for (int i = 0; i < snapshottabledirlisting_size(); i++) {
    if (!this->snapshottabledirlisting(i).IsInitialized()) return false;
  }
  return true;
}

void SnapshottableDirectoryListingProto::Swap(SnapshottableDirectoryListingProto* other) {
  if (other != this) {
    snapshottabledirlisting_.Swap(&other->snapshottabledirlisting_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SnapshottableDirectoryListingProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SnapshottableDirectoryListingProto_descriptor_;
  metadata.reflection = SnapshottableDirectoryListingProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SnapshotDiffReportEntryProto::kFullpathFieldNumber;
const int SnapshotDiffReportEntryProto::kModificationLabelFieldNumber;
#endif  // !_MSC_VER

SnapshotDiffReportEntryProto::SnapshotDiffReportEntryProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SnapshotDiffReportEntryProto::InitAsDefaultInstance() {
}

SnapshotDiffReportEntryProto::SnapshotDiffReportEntryProto(const SnapshotDiffReportEntryProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SnapshotDiffReportEntryProto::SharedCtor() {
  _cached_size_ = 0;
  fullpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  modificationlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SnapshotDiffReportEntryProto::~SnapshotDiffReportEntryProto() {
  SharedDtor();
}

void SnapshotDiffReportEntryProto::SharedDtor() {
  if (fullpath_ != &::google::protobuf::internal::kEmptyString) {
    delete fullpath_;
  }
  if (modificationlabel_ != &::google::protobuf::internal::kEmptyString) {
    delete modificationlabel_;
  }
  if (this != default_instance_) {
  }
}

void SnapshotDiffReportEntryProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SnapshotDiffReportEntryProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SnapshotDiffReportEntryProto_descriptor_;
}

const SnapshotDiffReportEntryProto& SnapshotDiffReportEntryProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

SnapshotDiffReportEntryProto* SnapshotDiffReportEntryProto::default_instance_ = NULL;

SnapshotDiffReportEntryProto* SnapshotDiffReportEntryProto::New() const {
  return new SnapshotDiffReportEntryProto;
}

void SnapshotDiffReportEntryProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_fullpath()) {
      if (fullpath_ != &::google::protobuf::internal::kEmptyString) {
        fullpath_->clear();
      }
    }
    if (has_modificationlabel()) {
      if (modificationlabel_ != &::google::protobuf::internal::kEmptyString) {
        modificationlabel_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SnapshotDiffReportEntryProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes fullpath = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_fullpath()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_modificationLabel;
        break;
      }

      // required string modificationLabel = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_modificationLabel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_modificationlabel()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->modificationlabel().data(), this->modificationlabel().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SnapshotDiffReportEntryProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes fullpath = 1;
  if (has_fullpath()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->fullpath(), output);
  }

  // required string modificationLabel = 2;
  if (has_modificationlabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->modificationlabel().data(), this->modificationlabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->modificationlabel(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SnapshotDiffReportEntryProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes fullpath = 1;
  if (has_fullpath()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->fullpath(), target);
  }

  // required string modificationLabel = 2;
  if (has_modificationlabel()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->modificationlabel().data(), this->modificationlabel().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->modificationlabel(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SnapshotDiffReportEntryProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes fullpath = 1;
    if (has_fullpath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->fullpath());
    }

    // required string modificationLabel = 2;
    if (has_modificationlabel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->modificationlabel());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SnapshotDiffReportEntryProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SnapshotDiffReportEntryProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SnapshotDiffReportEntryProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SnapshotDiffReportEntryProto::MergeFrom(const SnapshotDiffReportEntryProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fullpath()) {
      set_fullpath(from.fullpath());
    }
    if (from.has_modificationlabel()) {
      set_modificationlabel(from.modificationlabel());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SnapshotDiffReportEntryProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshotDiffReportEntryProto::CopyFrom(const SnapshotDiffReportEntryProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotDiffReportEntryProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SnapshotDiffReportEntryProto::Swap(SnapshotDiffReportEntryProto* other) {
  if (other != this) {
    std::swap(fullpath_, other->fullpath_);
    std::swap(modificationlabel_, other->modificationlabel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SnapshotDiffReportEntryProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SnapshotDiffReportEntryProto_descriptor_;
  metadata.reflection = SnapshotDiffReportEntryProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SnapshotDiffReportProto::kSnapshotRootFieldNumber;
const int SnapshotDiffReportProto::kFromSnapshotFieldNumber;
const int SnapshotDiffReportProto::kToSnapshotFieldNumber;
const int SnapshotDiffReportProto::kDiffReportEntriesFieldNumber;
#endif  // !_MSC_VER

SnapshotDiffReportProto::SnapshotDiffReportProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SnapshotDiffReportProto::InitAsDefaultInstance() {
}

SnapshotDiffReportProto::SnapshotDiffReportProto(const SnapshotDiffReportProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SnapshotDiffReportProto::SharedCtor() {
  _cached_size_ = 0;
  snapshotroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fromsnapshot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  tosnapshot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SnapshotDiffReportProto::~SnapshotDiffReportProto() {
  SharedDtor();
}

void SnapshotDiffReportProto::SharedDtor() {
  if (snapshotroot_ != &::google::protobuf::internal::kEmptyString) {
    delete snapshotroot_;
  }
  if (fromsnapshot_ != &::google::protobuf::internal::kEmptyString) {
    delete fromsnapshot_;
  }
  if (tosnapshot_ != &::google::protobuf::internal::kEmptyString) {
    delete tosnapshot_;
  }
  if (this != default_instance_) {
  }
}

void SnapshotDiffReportProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SnapshotDiffReportProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SnapshotDiffReportProto_descriptor_;
}

const SnapshotDiffReportProto& SnapshotDiffReportProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

SnapshotDiffReportProto* SnapshotDiffReportProto::default_instance_ = NULL;

SnapshotDiffReportProto* SnapshotDiffReportProto::New() const {
  return new SnapshotDiffReportProto;
}

void SnapshotDiffReportProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_snapshotroot()) {
      if (snapshotroot_ != &::google::protobuf::internal::kEmptyString) {
        snapshotroot_->clear();
      }
    }
    if (has_fromsnapshot()) {
      if (fromsnapshot_ != &::google::protobuf::internal::kEmptyString) {
        fromsnapshot_->clear();
      }
    }
    if (has_tosnapshot()) {
      if (tosnapshot_ != &::google::protobuf::internal::kEmptyString) {
        tosnapshot_->clear();
      }
    }
  }
  diffreportentries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SnapshotDiffReportProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string snapshotRoot = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_snapshotroot()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->snapshotroot().data(), this->snapshotroot().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_fromSnapshot;
        break;
      }

      // required string fromSnapshot = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fromSnapshot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fromsnapshot()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->fromsnapshot().data(), this->fromsnapshot().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_toSnapshot;
        break;
      }

      // required string toSnapshot = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_toSnapshot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tosnapshot()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->tosnapshot().data(), this->tosnapshot().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_diffReportEntries;
        break;
      }

      // repeated .hadoop.hdfs.SnapshotDiffReportEntryProto diffReportEntries = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_diffReportEntries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_diffreportentries()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_diffReportEntries;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SnapshotDiffReportProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string snapshotRoot = 1;
  if (has_snapshotroot()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->snapshotroot().data(), this->snapshotroot().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->snapshotroot(), output);
  }

  // required string fromSnapshot = 2;
  if (has_fromsnapshot()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->fromsnapshot().data(), this->fromsnapshot().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->fromsnapshot(), output);
  }

  // required string toSnapshot = 3;
  if (has_tosnapshot()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tosnapshot().data(), this->tosnapshot().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->tosnapshot(), output);
  }

  // repeated .hadoop.hdfs.SnapshotDiffReportEntryProto diffReportEntries = 4;
  for (int i = 0; i < this->diffreportentries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->diffreportentries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SnapshotDiffReportProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string snapshotRoot = 1;
  if (has_snapshotroot()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->snapshotroot().data(), this->snapshotroot().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->snapshotroot(), target);
  }

  // required string fromSnapshot = 2;
  if (has_fromsnapshot()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->fromsnapshot().data(), this->fromsnapshot().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->fromsnapshot(), target);
  }

  // required string toSnapshot = 3;
  if (has_tosnapshot()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->tosnapshot().data(), this->tosnapshot().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->tosnapshot(), target);
  }

  // repeated .hadoop.hdfs.SnapshotDiffReportEntryProto diffReportEntries = 4;
  for (int i = 0; i < this->diffreportentries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->diffreportentries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SnapshotDiffReportProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string snapshotRoot = 1;
    if (has_snapshotroot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->snapshotroot());
    }

    // required string fromSnapshot = 2;
    if (has_fromsnapshot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fromsnapshot());
    }

    // required string toSnapshot = 3;
    if (has_tosnapshot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tosnapshot());
    }

  }
  // repeated .hadoop.hdfs.SnapshotDiffReportEntryProto diffReportEntries = 4;
  total_size += 1 * this->diffreportentries_size();
  for (int i = 0; i < this->diffreportentries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->diffreportentries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SnapshotDiffReportProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SnapshotDiffReportProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SnapshotDiffReportProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SnapshotDiffReportProto::MergeFrom(const SnapshotDiffReportProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  diffreportentries_.MergeFrom(from.diffreportentries_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_snapshotroot()) {
      set_snapshotroot(from.snapshotroot());
    }
    if (from.has_fromsnapshot()) {
      set_fromsnapshot(from.fromsnapshot());
    }
    if (from.has_tosnapshot()) {
      set_tosnapshot(from.tosnapshot());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SnapshotDiffReportProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshotDiffReportProto::CopyFrom(const SnapshotDiffReportProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotDiffReportProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  for (int i = 0; i < diffreportentries_size(); i++) {
    if (!this->diffreportentries(i).IsInitialized()) return false;
  }
  return true;
}

void SnapshotDiffReportProto::Swap(SnapshotDiffReportProto* other) {
  if (other != this) {
    std::swap(snapshotroot_, other->snapshotroot_);
    std::swap(fromsnapshot_, other->fromsnapshot_);
    std::swap(tosnapshot_, other->tosnapshot_);
    diffreportentries_.Swap(&other->diffreportentries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SnapshotDiffReportProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SnapshotDiffReportProto_descriptor_;
  metadata.reflection = SnapshotDiffReportProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StorageInfoProto::kLayoutVersionFieldNumber;
const int StorageInfoProto::kNamespceIDFieldNumber;
const int StorageInfoProto::kClusterIDFieldNumber;
const int StorageInfoProto::kCTimeFieldNumber;
#endif  // !_MSC_VER

StorageInfoProto::StorageInfoProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StorageInfoProto::InitAsDefaultInstance() {
}

StorageInfoProto::StorageInfoProto(const StorageInfoProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StorageInfoProto::SharedCtor() {
  _cached_size_ = 0;
  layoutversion_ = 0u;
  namespceid_ = 0u;
  clusterid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ctime_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StorageInfoProto::~StorageInfoProto() {
  SharedDtor();
}

void StorageInfoProto::SharedDtor() {
  if (clusterid_ != &::google::protobuf::internal::kEmptyString) {
    delete clusterid_;
  }
  if (this != default_instance_) {
  }
}

void StorageInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StorageInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StorageInfoProto_descriptor_;
}

const StorageInfoProto& StorageInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

StorageInfoProto* StorageInfoProto::default_instance_ = NULL;

StorageInfoProto* StorageInfoProto::New() const {
  return new StorageInfoProto;
}

void StorageInfoProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    layoutversion_ = 0u;
    namespceid_ = 0u;
    if (has_clusterid()) {
      if (clusterid_ != &::google::protobuf::internal::kEmptyString) {
        clusterid_->clear();
      }
    }
    ctime_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StorageInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 layoutVersion = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &layoutversion_)));
          set_has_layoutversion();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_namespceID;
        break;
      }

      // required uint32 namespceID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_namespceID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &namespceid_)));
          set_has_namespceid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_clusterID;
        break;
      }

      // required string clusterID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clusterID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clusterid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->clusterid().data(), this->clusterid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_cTime;
        break;
      }

      // required uint64 cTime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ctime_)));
          set_has_ctime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StorageInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 layoutVersion = 1;
  if (has_layoutversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->layoutversion(), output);
  }

  // required uint32 namespceID = 2;
  if (has_namespceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->namespceid(), output);
  }

  // required string clusterID = 3;
  if (has_clusterid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clusterid().data(), this->clusterid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->clusterid(), output);
  }

  // required uint64 cTime = 4;
  if (has_ctime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->ctime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StorageInfoProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 layoutVersion = 1;
  if (has_layoutversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->layoutversion(), target);
  }

  // required uint32 namespceID = 2;
  if (has_namespceid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->namespceid(), target);
  }

  // required string clusterID = 3;
  if (has_clusterid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clusterid().data(), this->clusterid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->clusterid(), target);
  }

  // required uint64 cTime = 4;
  if (has_ctime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->ctime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StorageInfoProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 layoutVersion = 1;
    if (has_layoutversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->layoutversion());
    }

    // required uint32 namespceID = 2;
    if (has_namespceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->namespceid());
    }

    // required string clusterID = 3;
    if (has_clusterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clusterid());
    }

    // required uint64 cTime = 4;
    if (has_ctime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ctime());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StorageInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StorageInfoProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StorageInfoProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StorageInfoProto::MergeFrom(const StorageInfoProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layoutversion()) {
      set_layoutversion(from.layoutversion());
    }
    if (from.has_namespceid()) {
      set_namespceid(from.namespceid());
    }
    if (from.has_clusterid()) {
      set_clusterid(from.clusterid());
    }
    if (from.has_ctime()) {
      set_ctime(from.ctime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StorageInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StorageInfoProto::CopyFrom(const StorageInfoProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void StorageInfoProto::Swap(StorageInfoProto* other) {
  if (other != this) {
    std::swap(layoutversion_, other->layoutversion_);
    std::swap(namespceid_, other->namespceid_);
    std::swap(clusterid_, other->clusterid_);
    std::swap(ctime_, other->ctime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StorageInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StorageInfoProto_descriptor_;
  metadata.reflection = StorageInfoProto_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* NamenodeRegistrationProto_NamenodeRoleProto_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NamenodeRegistrationProto_NamenodeRoleProto_descriptor_;
}
bool NamenodeRegistrationProto_NamenodeRoleProto_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto::NAMENODE;
const NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto::BACKUP;
const NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto::CHECKPOINT;
const NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto::NamenodeRoleProto_MIN;
const NamenodeRegistrationProto_NamenodeRoleProto NamenodeRegistrationProto::NamenodeRoleProto_MAX;
const int NamenodeRegistrationProto::NamenodeRoleProto_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int NamenodeRegistrationProto::kRpcAddressFieldNumber;
const int NamenodeRegistrationProto::kHttpAddressFieldNumber;
const int NamenodeRegistrationProto::kStorageInfoFieldNumber;
const int NamenodeRegistrationProto::kRoleFieldNumber;
#endif  // !_MSC_VER

NamenodeRegistrationProto::NamenodeRegistrationProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NamenodeRegistrationProto::InitAsDefaultInstance() {
  storageinfo_ = const_cast< ::hadoop::hdfs::StorageInfoProto*>(&::hadoop::hdfs::StorageInfoProto::default_instance());
}

NamenodeRegistrationProto::NamenodeRegistrationProto(const NamenodeRegistrationProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NamenodeRegistrationProto::SharedCtor() {
  _cached_size_ = 0;
  rpcaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  httpaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  storageinfo_ = NULL;
  role_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NamenodeRegistrationProto::~NamenodeRegistrationProto() {
  SharedDtor();
}

void NamenodeRegistrationProto::SharedDtor() {
  if (rpcaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete rpcaddress_;
  }
  if (httpaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete httpaddress_;
  }
  if (this != default_instance_) {
    delete storageinfo_;
  }
}

void NamenodeRegistrationProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NamenodeRegistrationProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NamenodeRegistrationProto_descriptor_;
}

const NamenodeRegistrationProto& NamenodeRegistrationProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

NamenodeRegistrationProto* NamenodeRegistrationProto::default_instance_ = NULL;

NamenodeRegistrationProto* NamenodeRegistrationProto::New() const {
  return new NamenodeRegistrationProto;
}

void NamenodeRegistrationProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_rpcaddress()) {
      if (rpcaddress_ != &::google::protobuf::internal::kEmptyString) {
        rpcaddress_->clear();
      }
    }
    if (has_httpaddress()) {
      if (httpaddress_ != &::google::protobuf::internal::kEmptyString) {
        httpaddress_->clear();
      }
    }
    if (has_storageinfo()) {
      if (storageinfo_ != NULL) storageinfo_->::hadoop::hdfs::StorageInfoProto::Clear();
    }
    role_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NamenodeRegistrationProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string rpcAddress = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rpcaddress()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->rpcaddress().data(), this->rpcaddress().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_httpAddress;
        break;
      }

      // required string httpAddress = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_httpAddress:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_httpaddress()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->httpaddress().data(), this->httpaddress().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_storageInfo;
        break;
      }

      // required .hadoop.hdfs.StorageInfoProto storageInfo = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_storageInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_storageinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_role;
        break;
      }

      // optional .hadoop.hdfs.NamenodeRegistrationProto.NamenodeRoleProto role = 4 [default = NAMENODE];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_role:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hadoop::hdfs::NamenodeRegistrationProto_NamenodeRoleProto_IsValid(value)) {
            set_role(static_cast< ::hadoop::hdfs::NamenodeRegistrationProto_NamenodeRoleProto >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NamenodeRegistrationProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string rpcAddress = 1;
  if (has_rpcaddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->rpcaddress().data(), this->rpcaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->rpcaddress(), output);
  }

  // required string httpAddress = 2;
  if (has_httpaddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->httpaddress().data(), this->httpaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->httpaddress(), output);
  }

  // required .hadoop.hdfs.StorageInfoProto storageInfo = 3;
  if (has_storageinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->storageinfo(), output);
  }

  // optional .hadoop.hdfs.NamenodeRegistrationProto.NamenodeRoleProto role = 4 [default = NAMENODE];
  if (has_role()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->role(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NamenodeRegistrationProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string rpcAddress = 1;
  if (has_rpcaddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->rpcaddress().data(), this->rpcaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->rpcaddress(), target);
  }

  // required string httpAddress = 2;
  if (has_httpaddress()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->httpaddress().data(), this->httpaddress().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->httpaddress(), target);
  }

  // required .hadoop.hdfs.StorageInfoProto storageInfo = 3;
  if (has_storageinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->storageinfo(), target);
  }

  // optional .hadoop.hdfs.NamenodeRegistrationProto.NamenodeRoleProto role = 4 [default = NAMENODE];
  if (has_role()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->role(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NamenodeRegistrationProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string rpcAddress = 1;
    if (has_rpcaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->rpcaddress());
    }

    // required string httpAddress = 2;
    if (has_httpaddress()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->httpaddress());
    }

    // required .hadoop.hdfs.StorageInfoProto storageInfo = 3;
    if (has_storageinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->storageinfo());
    }

    // optional .hadoop.hdfs.NamenodeRegistrationProto.NamenodeRoleProto role = 4 [default = NAMENODE];
    if (has_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->role());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NamenodeRegistrationProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NamenodeRegistrationProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NamenodeRegistrationProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NamenodeRegistrationProto::MergeFrom(const NamenodeRegistrationProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rpcaddress()) {
      set_rpcaddress(from.rpcaddress());
    }
    if (from.has_httpaddress()) {
      set_httpaddress(from.httpaddress());
    }
    if (from.has_storageinfo()) {
      mutable_storageinfo()->::hadoop::hdfs::StorageInfoProto::MergeFrom(from.storageinfo());
    }
    if (from.has_role()) {
      set_role(from.role());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NamenodeRegistrationProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamenodeRegistrationProto::CopyFrom(const NamenodeRegistrationProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamenodeRegistrationProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_storageinfo()) {
    if (!this->storageinfo().IsInitialized()) return false;
  }
  return true;
}

void NamenodeRegistrationProto::Swap(NamenodeRegistrationProto* other) {
  if (other != this) {
    std::swap(rpcaddress_, other->rpcaddress_);
    std::swap(httpaddress_, other->httpaddress_);
    std::swap(storageinfo_, other->storageinfo_);
    std::swap(role_, other->role_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NamenodeRegistrationProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NamenodeRegistrationProto_descriptor_;
  metadata.reflection = NamenodeRegistrationProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckpointSignatureProto::kBlockPoolIdFieldNumber;
const int CheckpointSignatureProto::kMostRecentCheckpointTxIdFieldNumber;
const int CheckpointSignatureProto::kCurSegmentTxIdFieldNumber;
const int CheckpointSignatureProto::kStorageInfoFieldNumber;
#endif  // !_MSC_VER

CheckpointSignatureProto::CheckpointSignatureProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CheckpointSignatureProto::InitAsDefaultInstance() {
  storageinfo_ = const_cast< ::hadoop::hdfs::StorageInfoProto*>(&::hadoop::hdfs::StorageInfoProto::default_instance());
}

CheckpointSignatureProto::CheckpointSignatureProto(const CheckpointSignatureProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CheckpointSignatureProto::SharedCtor() {
  _cached_size_ = 0;
  blockpoolid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mostrecentcheckpointtxid_ = GOOGLE_ULONGLONG(0);
  cursegmenttxid_ = GOOGLE_ULONGLONG(0);
  storageinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckpointSignatureProto::~CheckpointSignatureProto() {
  SharedDtor();
}

void CheckpointSignatureProto::SharedDtor() {
  if (blockpoolid_ != &::google::protobuf::internal::kEmptyString) {
    delete blockpoolid_;
  }
  if (this != default_instance_) {
    delete storageinfo_;
  }
}

void CheckpointSignatureProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckpointSignatureProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckpointSignatureProto_descriptor_;
}

const CheckpointSignatureProto& CheckpointSignatureProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

CheckpointSignatureProto* CheckpointSignatureProto::default_instance_ = NULL;

CheckpointSignatureProto* CheckpointSignatureProto::New() const {
  return new CheckpointSignatureProto;
}

void CheckpointSignatureProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_blockpoolid()) {
      if (blockpoolid_ != &::google::protobuf::internal::kEmptyString) {
        blockpoolid_->clear();
      }
    }
    mostrecentcheckpointtxid_ = GOOGLE_ULONGLONG(0);
    cursegmenttxid_ = GOOGLE_ULONGLONG(0);
    if (has_storageinfo()) {
      if (storageinfo_ != NULL) storageinfo_->::hadoop::hdfs::StorageInfoProto::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckpointSignatureProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string blockPoolId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_blockpoolid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->blockpoolid().data(), this->blockpoolid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mostRecentCheckpointTxId;
        break;
      }

      // required uint64 mostRecentCheckpointTxId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mostRecentCheckpointTxId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mostrecentcheckpointtxid_)));
          set_has_mostrecentcheckpointtxid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_curSegmentTxId;
        break;
      }

      // required uint64 curSegmentTxId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curSegmentTxId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cursegmenttxid_)));
          set_has_cursegmenttxid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_storageInfo;
        break;
      }

      // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_storageInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_storageinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckpointSignatureProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string blockPoolId = 1;
  if (has_blockpoolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->blockpoolid().data(), this->blockpoolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->blockpoolid(), output);
  }

  // required uint64 mostRecentCheckpointTxId = 2;
  if (has_mostrecentcheckpointtxid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->mostrecentcheckpointtxid(), output);
  }

  // required uint64 curSegmentTxId = 3;
  if (has_cursegmenttxid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->cursegmenttxid(), output);
  }

  // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;
  if (has_storageinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->storageinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CheckpointSignatureProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string blockPoolId = 1;
  if (has_blockpoolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->blockpoolid().data(), this->blockpoolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->blockpoolid(), target);
  }

  // required uint64 mostRecentCheckpointTxId = 2;
  if (has_mostrecentcheckpointtxid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->mostrecentcheckpointtxid(), target);
  }

  // required uint64 curSegmentTxId = 3;
  if (has_cursegmenttxid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->cursegmenttxid(), target);
  }

  // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;
  if (has_storageinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->storageinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CheckpointSignatureProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string blockPoolId = 1;
    if (has_blockpoolid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->blockpoolid());
    }

    // required uint64 mostRecentCheckpointTxId = 2;
    if (has_mostrecentcheckpointtxid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mostrecentcheckpointtxid());
    }

    // required uint64 curSegmentTxId = 3;
    if (has_cursegmenttxid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cursegmenttxid());
    }

    // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;
    if (has_storageinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->storageinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckpointSignatureProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckpointSignatureProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckpointSignatureProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckpointSignatureProto::MergeFrom(const CheckpointSignatureProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_blockpoolid()) {
      set_blockpoolid(from.blockpoolid());
    }
    if (from.has_mostrecentcheckpointtxid()) {
      set_mostrecentcheckpointtxid(from.mostrecentcheckpointtxid());
    }
    if (from.has_cursegmenttxid()) {
      set_cursegmenttxid(from.cursegmenttxid());
    }
    if (from.has_storageinfo()) {
      mutable_storageinfo()->::hadoop::hdfs::StorageInfoProto::MergeFrom(from.storageinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckpointSignatureProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckpointSignatureProto::CopyFrom(const CheckpointSignatureProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckpointSignatureProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_storageinfo()) {
    if (!this->storageinfo().IsInitialized()) return false;
  }
  return true;
}

void CheckpointSignatureProto::Swap(CheckpointSignatureProto* other) {
  if (other != this) {
    std::swap(blockpoolid_, other->blockpoolid_);
    std::swap(mostrecentcheckpointtxid_, other->mostrecentcheckpointtxid_);
    std::swap(cursegmenttxid_, other->cursegmenttxid_);
    std::swap(storageinfo_, other->storageinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckpointSignatureProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckpointSignatureProto_descriptor_;
  metadata.reflection = CheckpointSignatureProto_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* NamenodeCommandProto_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NamenodeCommandProto_Type_descriptor_;
}
bool NamenodeCommandProto_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const NamenodeCommandProto_Type NamenodeCommandProto::NamenodeCommand;
const NamenodeCommandProto_Type NamenodeCommandProto::CheckPointCommand;
const NamenodeCommandProto_Type NamenodeCommandProto::Type_MIN;
const NamenodeCommandProto_Type NamenodeCommandProto::Type_MAX;
const int NamenodeCommandProto::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int NamenodeCommandProto::kActionFieldNumber;
const int NamenodeCommandProto::kTypeFieldNumber;
const int NamenodeCommandProto::kCheckpointCmdFieldNumber;
#endif  // !_MSC_VER

NamenodeCommandProto::NamenodeCommandProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NamenodeCommandProto::InitAsDefaultInstance() {
  checkpointcmd_ = const_cast< ::hadoop::hdfs::CheckpointCommandProto*>(&::hadoop::hdfs::CheckpointCommandProto::default_instance());
}

NamenodeCommandProto::NamenodeCommandProto(const NamenodeCommandProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NamenodeCommandProto::SharedCtor() {
  _cached_size_ = 0;
  action_ = 0u;
  type_ = 0;
  checkpointcmd_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NamenodeCommandProto::~NamenodeCommandProto() {
  SharedDtor();
}

void NamenodeCommandProto::SharedDtor() {
  if (this != default_instance_) {
    delete checkpointcmd_;
  }
}

void NamenodeCommandProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NamenodeCommandProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NamenodeCommandProto_descriptor_;
}

const NamenodeCommandProto& NamenodeCommandProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

NamenodeCommandProto* NamenodeCommandProto::default_instance_ = NULL;

NamenodeCommandProto* NamenodeCommandProto::New() const {
  return new NamenodeCommandProto;
}

void NamenodeCommandProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    action_ = 0u;
    type_ = 0;
    if (has_checkpointcmd()) {
      if (checkpointcmd_ != NULL) checkpointcmd_->::hadoop::hdfs::CheckpointCommandProto::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NamenodeCommandProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 action = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &action_)));
          set_has_action();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .hadoop.hdfs.NamenodeCommandProto.Type type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hadoop::hdfs::NamenodeCommandProto_Type_IsValid(value)) {
            set_type(static_cast< ::hadoop::hdfs::NamenodeCommandProto_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_checkpointCmd;
        break;
      }

      // optional .hadoop.hdfs.CheckpointCommandProto checkpointCmd = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_checkpointCmd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_checkpointcmd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NamenodeCommandProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 action = 1;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->action(), output);
  }

  // required .hadoop.hdfs.NamenodeCommandProto.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .hadoop.hdfs.CheckpointCommandProto checkpointCmd = 3;
  if (has_checkpointcmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->checkpointcmd(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NamenodeCommandProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 action = 1;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->action(), target);
  }

  // required .hadoop.hdfs.NamenodeCommandProto.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .hadoop.hdfs.CheckpointCommandProto checkpointCmd = 3;
  if (has_checkpointcmd()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->checkpointcmd(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NamenodeCommandProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 action = 1;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->action());
    }

    // required .hadoop.hdfs.NamenodeCommandProto.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .hadoop.hdfs.CheckpointCommandProto checkpointCmd = 3;
    if (has_checkpointcmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->checkpointcmd());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NamenodeCommandProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NamenodeCommandProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NamenodeCommandProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NamenodeCommandProto::MergeFrom(const NamenodeCommandProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_action()) {
      set_action(from.action());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_checkpointcmd()) {
      mutable_checkpointcmd()->::hadoop::hdfs::CheckpointCommandProto::MergeFrom(from.checkpointcmd());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NamenodeCommandProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamenodeCommandProto::CopyFrom(const NamenodeCommandProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamenodeCommandProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_checkpointcmd()) {
    if (!this->checkpointcmd().IsInitialized()) return false;
  }
  return true;
}

void NamenodeCommandProto::Swap(NamenodeCommandProto* other) {
  if (other != this) {
    std::swap(action_, other->action_);
    std::swap(type_, other->type_);
    std::swap(checkpointcmd_, other->checkpointcmd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NamenodeCommandProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NamenodeCommandProto_descriptor_;
  metadata.reflection = NamenodeCommandProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckpointCommandProto::kSignatureFieldNumber;
const int CheckpointCommandProto::kNeedToReturnImageFieldNumber;
#endif  // !_MSC_VER

CheckpointCommandProto::CheckpointCommandProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CheckpointCommandProto::InitAsDefaultInstance() {
  signature_ = const_cast< ::hadoop::hdfs::CheckpointSignatureProto*>(&::hadoop::hdfs::CheckpointSignatureProto::default_instance());
}

CheckpointCommandProto::CheckpointCommandProto(const CheckpointCommandProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CheckpointCommandProto::SharedCtor() {
  _cached_size_ = 0;
  signature_ = NULL;
  needtoreturnimage_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckpointCommandProto::~CheckpointCommandProto() {
  SharedDtor();
}

void CheckpointCommandProto::SharedDtor() {
  if (this != default_instance_) {
    delete signature_;
  }
}

void CheckpointCommandProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckpointCommandProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckpointCommandProto_descriptor_;
}

const CheckpointCommandProto& CheckpointCommandProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

CheckpointCommandProto* CheckpointCommandProto::default_instance_ = NULL;

CheckpointCommandProto* CheckpointCommandProto::New() const {
  return new CheckpointCommandProto;
}

void CheckpointCommandProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_signature()) {
      if (signature_ != NULL) signature_->::hadoop::hdfs::CheckpointSignatureProto::Clear();
    }
    needtoreturnimage_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckpointCommandProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hadoop.hdfs.CheckpointSignatureProto signature = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_needToReturnImage;
        break;
      }

      // required bool needToReturnImage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_needToReturnImage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &needtoreturnimage_)));
          set_has_needtoreturnimage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckpointCommandProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hadoop.hdfs.CheckpointSignatureProto signature = 1;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->signature(), output);
  }

  // required bool needToReturnImage = 2;
  if (has_needtoreturnimage()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->needtoreturnimage(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CheckpointCommandProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hadoop.hdfs.CheckpointSignatureProto signature = 1;
  if (has_signature()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->signature(), target);
  }

  // required bool needToReturnImage = 2;
  if (has_needtoreturnimage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->needtoreturnimage(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CheckpointCommandProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hadoop.hdfs.CheckpointSignatureProto signature = 1;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->signature());
    }

    // required bool needToReturnImage = 2;
    if (has_needtoreturnimage()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckpointCommandProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckpointCommandProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckpointCommandProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckpointCommandProto::MergeFrom(const CheckpointCommandProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signature()) {
      mutable_signature()->::hadoop::hdfs::CheckpointSignatureProto::MergeFrom(from.signature());
    }
    if (from.has_needtoreturnimage()) {
      set_needtoreturnimage(from.needtoreturnimage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckpointCommandProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckpointCommandProto::CopyFrom(const CheckpointCommandProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckpointCommandProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_signature()) {
    if (!this->signature().IsInitialized()) return false;
  }
  return true;
}

void CheckpointCommandProto::Swap(CheckpointCommandProto* other) {
  if (other != this) {
    std::swap(signature_, other->signature_);
    std::swap(needtoreturnimage_, other->needtoreturnimage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckpointCommandProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckpointCommandProto_descriptor_;
  metadata.reflection = CheckpointCommandProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlockProto::kBlockIdFieldNumber;
const int BlockProto::kGenStampFieldNumber;
const int BlockProto::kNumBytesFieldNumber;
#endif  // !_MSC_VER

BlockProto::BlockProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BlockProto::InitAsDefaultInstance() {
}

BlockProto::BlockProto(const BlockProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BlockProto::SharedCtor() {
  _cached_size_ = 0;
  blockid_ = GOOGLE_ULONGLONG(0);
  genstamp_ = GOOGLE_ULONGLONG(0);
  numbytes_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlockProto::~BlockProto() {
  SharedDtor();
}

void BlockProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BlockProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlockProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlockProto_descriptor_;
}

const BlockProto& BlockProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

BlockProto* BlockProto::default_instance_ = NULL;

BlockProto* BlockProto::New() const {
  return new BlockProto;
}

void BlockProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    blockid_ = GOOGLE_ULONGLONG(0);
    genstamp_ = GOOGLE_ULONGLONG(0);
    numbytes_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlockProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 blockId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &blockid_)));
          set_has_blockid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_genStamp;
        break;
      }

      // required uint64 genStamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_genStamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &genstamp_)));
          set_has_genstamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_numBytes;
        break;
      }

      // optional uint64 numBytes = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_numBytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &numbytes_)));
          set_has_numbytes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlockProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 blockId = 1;
  if (has_blockid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->blockid(), output);
  }

  // required uint64 genStamp = 2;
  if (has_genstamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->genstamp(), output);
  }

  // optional uint64 numBytes = 3 [default = 0];
  if (has_numbytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->numbytes(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BlockProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 blockId = 1;
  if (has_blockid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->blockid(), target);
  }

  // required uint64 genStamp = 2;
  if (has_genstamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->genstamp(), target);
  }

  // optional uint64 numBytes = 3 [default = 0];
  if (has_numbytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->numbytes(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BlockProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 blockId = 1;
    if (has_blockid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->blockid());
    }

    // required uint64 genStamp = 2;
    if (has_genstamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->genstamp());
    }

    // optional uint64 numBytes = 3 [default = 0];
    if (has_numbytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->numbytes());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlockProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlockProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlockProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlockProto::MergeFrom(const BlockProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_blockid()) {
      set_blockid(from.blockid());
    }
    if (from.has_genstamp()) {
      set_genstamp(from.genstamp());
    }
    if (from.has_numbytes()) {
      set_numbytes(from.numbytes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlockProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockProto::CopyFrom(const BlockProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BlockProto::Swap(BlockProto* other) {
  if (other != this) {
    std::swap(blockid_, other->blockid_);
    std::swap(genstamp_, other->genstamp_);
    std::swap(numbytes_, other->numbytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlockProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlockProto_descriptor_;
  metadata.reflection = BlockProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlockWithLocationsProto::kBlockFieldNumber;
const int BlockWithLocationsProto::kDatanodeUuidsFieldNumber;
const int BlockWithLocationsProto::kStorageUuidsFieldNumber;
#endif  // !_MSC_VER

BlockWithLocationsProto::BlockWithLocationsProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BlockWithLocationsProto::InitAsDefaultInstance() {
  block_ = const_cast< ::hadoop::hdfs::BlockProto*>(&::hadoop::hdfs::BlockProto::default_instance());
}

BlockWithLocationsProto::BlockWithLocationsProto(const BlockWithLocationsProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BlockWithLocationsProto::SharedCtor() {
  _cached_size_ = 0;
  block_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlockWithLocationsProto::~BlockWithLocationsProto() {
  SharedDtor();
}

void BlockWithLocationsProto::SharedDtor() {
  if (this != default_instance_) {
    delete block_;
  }
}

void BlockWithLocationsProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlockWithLocationsProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlockWithLocationsProto_descriptor_;
}

const BlockWithLocationsProto& BlockWithLocationsProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

BlockWithLocationsProto* BlockWithLocationsProto::default_instance_ = NULL;

BlockWithLocationsProto* BlockWithLocationsProto::New() const {
  return new BlockWithLocationsProto;
}

void BlockWithLocationsProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_block()) {
      if (block_ != NULL) block_->::hadoop::hdfs::BlockProto::Clear();
    }
  }
  datanodeuuids_.Clear();
  storageuuids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlockWithLocationsProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hadoop.hdfs.BlockProto block = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_block()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_datanodeUuids;
        break;
      }

      // repeated string datanodeUuids = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_datanodeUuids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_datanodeuuids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->datanodeuuids(this->datanodeuuids_size() - 1).data(),
            this->datanodeuuids(this->datanodeuuids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_datanodeUuids;
        if (input->ExpectTag(26)) goto parse_storageUuids;
        break;
      }

      // repeated string storageUuids = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_storageUuids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_storageuuids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->storageuuids(this->storageuuids_size() - 1).data(),
            this->storageuuids(this->storageuuids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_storageUuids;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlockWithLocationsProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hadoop.hdfs.BlockProto block = 1;
  if (has_block()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->block(), output);
  }

  // repeated string datanodeUuids = 2;
  for (int i = 0; i < this->datanodeuuids_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->datanodeuuids(i).data(), this->datanodeuuids(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->datanodeuuids(i), output);
  }

  // repeated string storageUuids = 3;
  for (int i = 0; i < this->storageuuids_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->storageuuids(i).data(), this->storageuuids(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->storageuuids(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BlockWithLocationsProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hadoop.hdfs.BlockProto block = 1;
  if (has_block()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->block(), target);
  }

  // repeated string datanodeUuids = 2;
  for (int i = 0; i < this->datanodeuuids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->datanodeuuids(i).data(), this->datanodeuuids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->datanodeuuids(i), target);
  }

  // repeated string storageUuids = 3;
  for (int i = 0; i < this->storageuuids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->storageuuids(i).data(), this->storageuuids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->storageuuids(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BlockWithLocationsProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hadoop.hdfs.BlockProto block = 1;
    if (has_block()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->block());
    }

  }
  // repeated string datanodeUuids = 2;
  total_size += 1 * this->datanodeuuids_size();
  for (int i = 0; i < this->datanodeuuids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->datanodeuuids(i));
  }

  // repeated string storageUuids = 3;
  total_size += 1 * this->storageuuids_size();
  for (int i = 0; i < this->storageuuids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->storageuuids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlockWithLocationsProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlockWithLocationsProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlockWithLocationsProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlockWithLocationsProto::MergeFrom(const BlockWithLocationsProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  datanodeuuids_.MergeFrom(from.datanodeuuids_);
  storageuuids_.MergeFrom(from.storageuuids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_block()) {
      mutable_block()->::hadoop::hdfs::BlockProto::MergeFrom(from.block());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlockWithLocationsProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockWithLocationsProto::CopyFrom(const BlockWithLocationsProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockWithLocationsProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_block()) {
    if (!this->block().IsInitialized()) return false;
  }
  return true;
}

void BlockWithLocationsProto::Swap(BlockWithLocationsProto* other) {
  if (other != this) {
    std::swap(block_, other->block_);
    datanodeuuids_.Swap(&other->datanodeuuids_);
    storageuuids_.Swap(&other->storageuuids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlockWithLocationsProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlockWithLocationsProto_descriptor_;
  metadata.reflection = BlockWithLocationsProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlocksWithLocationsProto::kBlocksFieldNumber;
#endif  // !_MSC_VER

BlocksWithLocationsProto::BlocksWithLocationsProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BlocksWithLocationsProto::InitAsDefaultInstance() {
}

BlocksWithLocationsProto::BlocksWithLocationsProto(const BlocksWithLocationsProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BlocksWithLocationsProto::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlocksWithLocationsProto::~BlocksWithLocationsProto() {
  SharedDtor();
}

void BlocksWithLocationsProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BlocksWithLocationsProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlocksWithLocationsProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlocksWithLocationsProto_descriptor_;
}

const BlocksWithLocationsProto& BlocksWithLocationsProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

BlocksWithLocationsProto* BlocksWithLocationsProto::default_instance_ = NULL;

BlocksWithLocationsProto* BlocksWithLocationsProto::New() const {
  return new BlocksWithLocationsProto;
}

void BlocksWithLocationsProto::Clear() {
  blocks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlocksWithLocationsProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hadoop.hdfs.BlockWithLocationsProto blocks = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_blocks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_blocks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_blocks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlocksWithLocationsProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hadoop.hdfs.BlockWithLocationsProto blocks = 1;
  for (int i = 0; i < this->blocks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->blocks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BlocksWithLocationsProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hadoop.hdfs.BlockWithLocationsProto blocks = 1;
  for (int i = 0; i < this->blocks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->blocks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BlocksWithLocationsProto::ByteSize() const {
  int total_size = 0;

  // repeated .hadoop.hdfs.BlockWithLocationsProto blocks = 1;
  total_size += 1 * this->blocks_size();
  for (int i = 0; i < this->blocks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->blocks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlocksWithLocationsProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlocksWithLocationsProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlocksWithLocationsProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlocksWithLocationsProto::MergeFrom(const BlocksWithLocationsProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  blocks_.MergeFrom(from.blocks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlocksWithLocationsProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlocksWithLocationsProto::CopyFrom(const BlocksWithLocationsProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlocksWithLocationsProto::IsInitialized() const {

  for (int i = 0; i < blocks_size(); i++) {
    if (!this->blocks(i).IsInitialized()) return false;
  }
  return true;
}

void BlocksWithLocationsProto::Swap(BlocksWithLocationsProto* other) {
  if (other != this) {
    blocks_.Swap(&other->blocks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlocksWithLocationsProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlocksWithLocationsProto_descriptor_;
  metadata.reflection = BlocksWithLocationsProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RemoteEditLogProto::kStartTxIdFieldNumber;
const int RemoteEditLogProto::kEndTxIdFieldNumber;
const int RemoteEditLogProto::kIsInProgressFieldNumber;
#endif  // !_MSC_VER

RemoteEditLogProto::RemoteEditLogProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RemoteEditLogProto::InitAsDefaultInstance() {
}

RemoteEditLogProto::RemoteEditLogProto(const RemoteEditLogProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RemoteEditLogProto::SharedCtor() {
  _cached_size_ = 0;
  starttxid_ = GOOGLE_ULONGLONG(0);
  endtxid_ = GOOGLE_ULONGLONG(0);
  isinprogress_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoteEditLogProto::~RemoteEditLogProto() {
  SharedDtor();
}

void RemoteEditLogProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RemoteEditLogProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RemoteEditLogProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RemoteEditLogProto_descriptor_;
}

const RemoteEditLogProto& RemoteEditLogProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

RemoteEditLogProto* RemoteEditLogProto::default_instance_ = NULL;

RemoteEditLogProto* RemoteEditLogProto::New() const {
  return new RemoteEditLogProto;
}

void RemoteEditLogProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    starttxid_ = GOOGLE_ULONGLONG(0);
    endtxid_ = GOOGLE_ULONGLONG(0);
    isinprogress_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RemoteEditLogProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 startTxId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &starttxid_)));
          set_has_starttxid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_endTxId;
        break;
      }

      // required uint64 endTxId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_endTxId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &endtxid_)));
          set_has_endtxid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_isInProgress;
        break;
      }

      // optional bool isInProgress = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isInProgress:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isinprogress_)));
          set_has_isinprogress();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RemoteEditLogProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 startTxId = 1;
  if (has_starttxid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->starttxid(), output);
  }

  // required uint64 endTxId = 2;
  if (has_endtxid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->endtxid(), output);
  }

  // optional bool isInProgress = 3 [default = false];
  if (has_isinprogress()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isinprogress(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RemoteEditLogProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 startTxId = 1;
  if (has_starttxid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->starttxid(), target);
  }

  // required uint64 endTxId = 2;
  if (has_endtxid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->endtxid(), target);
  }

  // optional bool isInProgress = 3 [default = false];
  if (has_isinprogress()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->isinprogress(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RemoteEditLogProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 startTxId = 1;
    if (has_starttxid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->starttxid());
    }

    // required uint64 endTxId = 2;
    if (has_endtxid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->endtxid());
    }

    // optional bool isInProgress = 3 [default = false];
    if (has_isinprogress()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RemoteEditLogProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RemoteEditLogProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RemoteEditLogProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RemoteEditLogProto::MergeFrom(const RemoteEditLogProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_starttxid()) {
      set_starttxid(from.starttxid());
    }
    if (from.has_endtxid()) {
      set_endtxid(from.endtxid());
    }
    if (from.has_isinprogress()) {
      set_isinprogress(from.isinprogress());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RemoteEditLogProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RemoteEditLogProto::CopyFrom(const RemoteEditLogProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteEditLogProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RemoteEditLogProto::Swap(RemoteEditLogProto* other) {
  if (other != this) {
    std::swap(starttxid_, other->starttxid_);
    std::swap(endtxid_, other->endtxid_);
    std::swap(isinprogress_, other->isinprogress_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RemoteEditLogProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RemoteEditLogProto_descriptor_;
  metadata.reflection = RemoteEditLogProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RemoteEditLogManifestProto::kLogsFieldNumber;
#endif  // !_MSC_VER

RemoteEditLogManifestProto::RemoteEditLogManifestProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RemoteEditLogManifestProto::InitAsDefaultInstance() {
}

RemoteEditLogManifestProto::RemoteEditLogManifestProto(const RemoteEditLogManifestProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RemoteEditLogManifestProto::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoteEditLogManifestProto::~RemoteEditLogManifestProto() {
  SharedDtor();
}

void RemoteEditLogManifestProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RemoteEditLogManifestProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RemoteEditLogManifestProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RemoteEditLogManifestProto_descriptor_;
}

const RemoteEditLogManifestProto& RemoteEditLogManifestProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

RemoteEditLogManifestProto* RemoteEditLogManifestProto::default_instance_ = NULL;

RemoteEditLogManifestProto* RemoteEditLogManifestProto::New() const {
  return new RemoteEditLogManifestProto;
}

void RemoteEditLogManifestProto::Clear() {
  logs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RemoteEditLogManifestProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hadoop.hdfs.RemoteEditLogProto logs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_logs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_logs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_logs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RemoteEditLogManifestProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .hadoop.hdfs.RemoteEditLogProto logs = 1;
  for (int i = 0; i < this->logs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->logs(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RemoteEditLogManifestProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .hadoop.hdfs.RemoteEditLogProto logs = 1;
  for (int i = 0; i < this->logs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->logs(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RemoteEditLogManifestProto::ByteSize() const {
  int total_size = 0;

  // repeated .hadoop.hdfs.RemoteEditLogProto logs = 1;
  total_size += 1 * this->logs_size();
  for (int i = 0; i < this->logs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->logs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RemoteEditLogManifestProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RemoteEditLogManifestProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RemoteEditLogManifestProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RemoteEditLogManifestProto::MergeFrom(const RemoteEditLogManifestProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  logs_.MergeFrom(from.logs_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RemoteEditLogManifestProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RemoteEditLogManifestProto::CopyFrom(const RemoteEditLogManifestProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteEditLogManifestProto::IsInitialized() const {

  for (int i = 0; i < logs_size(); i++) {
    if (!this->logs(i).IsInitialized()) return false;
  }
  return true;
}

void RemoteEditLogManifestProto::Swap(RemoteEditLogManifestProto* other) {
  if (other != this) {
    logs_.Swap(&other->logs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RemoteEditLogManifestProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RemoteEditLogManifestProto_descriptor_;
  metadata.reflection = RemoteEditLogManifestProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NamespaceInfoProto::kBuildVersionFieldNumber;
const int NamespaceInfoProto::kUnusedFieldNumber;
const int NamespaceInfoProto::kBlockPoolIDFieldNumber;
const int NamespaceInfoProto::kStorageInfoFieldNumber;
const int NamespaceInfoProto::kSoftwareVersionFieldNumber;
#endif  // !_MSC_VER

NamespaceInfoProto::NamespaceInfoProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NamespaceInfoProto::InitAsDefaultInstance() {
  storageinfo_ = const_cast< ::hadoop::hdfs::StorageInfoProto*>(&::hadoop::hdfs::StorageInfoProto::default_instance());
}

NamespaceInfoProto::NamespaceInfoProto(const NamespaceInfoProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NamespaceInfoProto::SharedCtor() {
  _cached_size_ = 0;
  buildversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  unused_ = 0u;
  blockpoolid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  storageinfo_ = NULL;
  softwareversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NamespaceInfoProto::~NamespaceInfoProto() {
  SharedDtor();
}

void NamespaceInfoProto::SharedDtor() {
  if (buildversion_ != &::google::protobuf::internal::kEmptyString) {
    delete buildversion_;
  }
  if (blockpoolid_ != &::google::protobuf::internal::kEmptyString) {
    delete blockpoolid_;
  }
  if (softwareversion_ != &::google::protobuf::internal::kEmptyString) {
    delete softwareversion_;
  }
  if (this != default_instance_) {
    delete storageinfo_;
  }
}

void NamespaceInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NamespaceInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NamespaceInfoProto_descriptor_;
}

const NamespaceInfoProto& NamespaceInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

NamespaceInfoProto* NamespaceInfoProto::default_instance_ = NULL;

NamespaceInfoProto* NamespaceInfoProto::New() const {
  return new NamespaceInfoProto;
}

void NamespaceInfoProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_buildversion()) {
      if (buildversion_ != &::google::protobuf::internal::kEmptyString) {
        buildversion_->clear();
      }
    }
    unused_ = 0u;
    if (has_blockpoolid()) {
      if (blockpoolid_ != &::google::protobuf::internal::kEmptyString) {
        blockpoolid_->clear();
      }
    }
    if (has_storageinfo()) {
      if (storageinfo_ != NULL) storageinfo_->::hadoop::hdfs::StorageInfoProto::Clear();
    }
    if (has_softwareversion()) {
      if (softwareversion_ != &::google::protobuf::internal::kEmptyString) {
        softwareversion_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NamespaceInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string buildVersion = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_buildversion()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->buildversion().data(), this->buildversion().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_unused;
        break;
      }

      // required uint32 unused = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unused:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unused_)));
          set_has_unused();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_blockPoolID;
        break;
      }

      // required string blockPoolID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_blockPoolID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_blockpoolid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->blockpoolid().data(), this->blockpoolid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_storageInfo;
        break;
      }

      // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_storageInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_storageinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_softwareVersion;
        break;
      }

      // required string softwareVersion = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_softwareVersion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_softwareversion()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->softwareversion().data(), this->softwareversion().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NamespaceInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string buildVersion = 1;
  if (has_buildversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buildversion().data(), this->buildversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->buildversion(), output);
  }

  // required uint32 unused = 2;
  if (has_unused()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->unused(), output);
  }

  // required string blockPoolID = 3;
  if (has_blockpoolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->blockpoolid().data(), this->blockpoolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->blockpoolid(), output);
  }

  // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;
  if (has_storageinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->storageinfo(), output);
  }

  // required string softwareVersion = 5;
  if (has_softwareversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->softwareversion().data(), this->softwareversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->softwareversion(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NamespaceInfoProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string buildVersion = 1;
  if (has_buildversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->buildversion().data(), this->buildversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->buildversion(), target);
  }

  // required uint32 unused = 2;
  if (has_unused()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->unused(), target);
  }

  // required string blockPoolID = 3;
  if (has_blockpoolid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->blockpoolid().data(), this->blockpoolid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->blockpoolid(), target);
  }

  // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;
  if (has_storageinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->storageinfo(), target);
  }

  // required string softwareVersion = 5;
  if (has_softwareversion()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->softwareversion().data(), this->softwareversion().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->softwareversion(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NamespaceInfoProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string buildVersion = 1;
    if (has_buildversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->buildversion());
    }

    // required uint32 unused = 2;
    if (has_unused()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unused());
    }

    // required string blockPoolID = 3;
    if (has_blockpoolid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->blockpoolid());
    }

    // required .hadoop.hdfs.StorageInfoProto storageInfo = 4;
    if (has_storageinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->storageinfo());
    }

    // required string softwareVersion = 5;
    if (has_softwareversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->softwareversion());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NamespaceInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NamespaceInfoProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NamespaceInfoProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NamespaceInfoProto::MergeFrom(const NamespaceInfoProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buildversion()) {
      set_buildversion(from.buildversion());
    }
    if (from.has_unused()) {
      set_unused(from.unused());
    }
    if (from.has_blockpoolid()) {
      set_blockpoolid(from.blockpoolid());
    }
    if (from.has_storageinfo()) {
      mutable_storageinfo()->::hadoop::hdfs::StorageInfoProto::MergeFrom(from.storageinfo());
    }
    if (from.has_softwareversion()) {
      set_softwareversion(from.softwareversion());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NamespaceInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamespaceInfoProto::CopyFrom(const NamespaceInfoProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespaceInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  if (has_storageinfo()) {
    if (!this->storageinfo().IsInitialized()) return false;
  }
  return true;
}

void NamespaceInfoProto::Swap(NamespaceInfoProto* other) {
  if (other != this) {
    std::swap(buildversion_, other->buildversion_);
    std::swap(unused_, other->unused_);
    std::swap(blockpoolid_, other->blockpoolid_);
    std::swap(storageinfo_, other->storageinfo_);
    std::swap(softwareversion_, other->softwareversion_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NamespaceInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NamespaceInfoProto_descriptor_;
  metadata.reflection = NamespaceInfoProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BlockKeyProto::kKeyIdFieldNumber;
const int BlockKeyProto::kExpiryDateFieldNumber;
const int BlockKeyProto::kKeyBytesFieldNumber;
#endif  // !_MSC_VER

BlockKeyProto::BlockKeyProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BlockKeyProto::InitAsDefaultInstance() {
}

BlockKeyProto::BlockKeyProto(const BlockKeyProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BlockKeyProto::SharedCtor() {
  _cached_size_ = 0;
  keyid_ = 0u;
  expirydate_ = GOOGLE_ULONGLONG(0);
  keybytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BlockKeyProto::~BlockKeyProto() {
  SharedDtor();
}

void BlockKeyProto::SharedDtor() {
  if (keybytes_ != &::google::protobuf::internal::kEmptyString) {
    delete keybytes_;
  }
  if (this != default_instance_) {
  }
}

void BlockKeyProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BlockKeyProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BlockKeyProto_descriptor_;
}

const BlockKeyProto& BlockKeyProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

BlockKeyProto* BlockKeyProto::default_instance_ = NULL;

BlockKeyProto* BlockKeyProto::New() const {
  return new BlockKeyProto;
}

void BlockKeyProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    keyid_ = 0u;
    expirydate_ = GOOGLE_ULONGLONG(0);
    if (has_keybytes()) {
      if (keybytes_ != &::google::protobuf::internal::kEmptyString) {
        keybytes_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BlockKeyProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 keyId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &keyid_)));
          set_has_keyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_expiryDate;
        break;
      }

      // required uint64 expiryDate = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_expiryDate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &expirydate_)));
          set_has_expirydate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_keyBytes;
        break;
      }

      // optional bytes keyBytes = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keyBytes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_keybytes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BlockKeyProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 keyId = 1;
  if (has_keyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->keyid(), output);
  }

  // required uint64 expiryDate = 2;
  if (has_expirydate()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->expirydate(), output);
  }

  // optional bytes keyBytes = 3;
  if (has_keybytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->keybytes(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BlockKeyProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 keyId = 1;
  if (has_keyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->keyid(), target);
  }

  // required uint64 expiryDate = 2;
  if (has_expirydate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->expirydate(), target);
  }

  // optional bytes keyBytes = 3;
  if (has_keybytes()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->keybytes(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BlockKeyProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 keyId = 1;
    if (has_keyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->keyid());
    }

    // required uint64 expiryDate = 2;
    if (has_expirydate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->expirydate());
    }

    // optional bytes keyBytes = 3;
    if (has_keybytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->keybytes());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BlockKeyProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BlockKeyProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BlockKeyProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BlockKeyProto::MergeFrom(const BlockKeyProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keyid()) {
      set_keyid(from.keyid());
    }
    if (from.has_expirydate()) {
      set_expirydate(from.expirydate());
    }
    if (from.has_keybytes()) {
      set_keybytes(from.keybytes());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BlockKeyProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockKeyProto::CopyFrom(const BlockKeyProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockKeyProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void BlockKeyProto::Swap(BlockKeyProto* other) {
  if (other != this) {
    std::swap(keyid_, other->keyid_);
    std::swap(expirydate_, other->expirydate_);
    std::swap(keybytes_, other->keybytes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BlockKeyProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BlockKeyProto_descriptor_;
  metadata.reflection = BlockKeyProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExportedBlockKeysProto::kIsBlockTokenEnabledFieldNumber;
const int ExportedBlockKeysProto::kKeyUpdateIntervalFieldNumber;
const int ExportedBlockKeysProto::kTokenLifeTimeFieldNumber;
const int ExportedBlockKeysProto::kCurrentKeyFieldNumber;
const int ExportedBlockKeysProto::kAllKeysFieldNumber;
#endif  // !_MSC_VER

ExportedBlockKeysProto::ExportedBlockKeysProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ExportedBlockKeysProto::InitAsDefaultInstance() {
  currentkey_ = const_cast< ::hadoop::hdfs::BlockKeyProto*>(&::hadoop::hdfs::BlockKeyProto::default_instance());
}

ExportedBlockKeysProto::ExportedBlockKeysProto(const ExportedBlockKeysProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ExportedBlockKeysProto::SharedCtor() {
  _cached_size_ = 0;
  isblocktokenenabled_ = false;
  keyupdateinterval_ = GOOGLE_ULONGLONG(0);
  tokenlifetime_ = GOOGLE_ULONGLONG(0);
  currentkey_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExportedBlockKeysProto::~ExportedBlockKeysProto() {
  SharedDtor();
}

void ExportedBlockKeysProto::SharedDtor() {
  if (this != default_instance_) {
    delete currentkey_;
  }
}

void ExportedBlockKeysProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExportedBlockKeysProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExportedBlockKeysProto_descriptor_;
}

const ExportedBlockKeysProto& ExportedBlockKeysProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

ExportedBlockKeysProto* ExportedBlockKeysProto::default_instance_ = NULL;

ExportedBlockKeysProto* ExportedBlockKeysProto::New() const {
  return new ExportedBlockKeysProto;
}

void ExportedBlockKeysProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    isblocktokenenabled_ = false;
    keyupdateinterval_ = GOOGLE_ULONGLONG(0);
    tokenlifetime_ = GOOGLE_ULONGLONG(0);
    if (has_currentkey()) {
      if (currentkey_ != NULL) currentkey_->::hadoop::hdfs::BlockKeyProto::Clear();
    }
  }
  allkeys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExportedBlockKeysProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool isBlockTokenEnabled = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isblocktokenenabled_)));
          set_has_isblocktokenenabled();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_keyUpdateInterval;
        break;
      }

      // required uint64 keyUpdateInterval = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_keyUpdateInterval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &keyupdateinterval_)));
          set_has_keyupdateinterval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_tokenLifeTime;
        break;
      }

      // required uint64 tokenLifeTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tokenLifeTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tokenlifetime_)));
          set_has_tokenlifetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_currentKey;
        break;
      }

      // required .hadoop.hdfs.BlockKeyProto currentKey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_currentKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_currentkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_allKeys;
        break;
      }

      // repeated .hadoop.hdfs.BlockKeyProto allKeys = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_allKeys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_allkeys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_allKeys;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExportedBlockKeysProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool isBlockTokenEnabled = 1;
  if (has_isblocktokenenabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->isblocktokenenabled(), output);
  }

  // required uint64 keyUpdateInterval = 2;
  if (has_keyupdateinterval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->keyupdateinterval(), output);
  }

  // required uint64 tokenLifeTime = 3;
  if (has_tokenlifetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->tokenlifetime(), output);
  }

  // required .hadoop.hdfs.BlockKeyProto currentKey = 4;
  if (has_currentkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->currentkey(), output);
  }

  // repeated .hadoop.hdfs.BlockKeyProto allKeys = 5;
  for (int i = 0; i < this->allkeys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->allkeys(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ExportedBlockKeysProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool isBlockTokenEnabled = 1;
  if (has_isblocktokenenabled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->isblocktokenenabled(), target);
  }

  // required uint64 keyUpdateInterval = 2;
  if (has_keyupdateinterval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->keyupdateinterval(), target);
  }

  // required uint64 tokenLifeTime = 3;
  if (has_tokenlifetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->tokenlifetime(), target);
  }

  // required .hadoop.hdfs.BlockKeyProto currentKey = 4;
  if (has_currentkey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->currentkey(), target);
  }

  // repeated .hadoop.hdfs.BlockKeyProto allKeys = 5;
  for (int i = 0; i < this->allkeys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->allkeys(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ExportedBlockKeysProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool isBlockTokenEnabled = 1;
    if (has_isblocktokenenabled()) {
      total_size += 1 + 1;
    }

    // required uint64 keyUpdateInterval = 2;
    if (has_keyupdateinterval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->keyupdateinterval());
    }

    // required uint64 tokenLifeTime = 3;
    if (has_tokenlifetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tokenlifetime());
    }

    // required .hadoop.hdfs.BlockKeyProto currentKey = 4;
    if (has_currentkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->currentkey());
    }

  }
  // repeated .hadoop.hdfs.BlockKeyProto allKeys = 5;
  total_size += 1 * this->allkeys_size();
  for (int i = 0; i < this->allkeys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->allkeys(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExportedBlockKeysProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExportedBlockKeysProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExportedBlockKeysProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExportedBlockKeysProto::MergeFrom(const ExportedBlockKeysProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  allkeys_.MergeFrom(from.allkeys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isblocktokenenabled()) {
      set_isblocktokenenabled(from.isblocktokenenabled());
    }
    if (from.has_keyupdateinterval()) {
      set_keyupdateinterval(from.keyupdateinterval());
    }
    if (from.has_tokenlifetime()) {
      set_tokenlifetime(from.tokenlifetime());
    }
    if (from.has_currentkey()) {
      mutable_currentkey()->::hadoop::hdfs::BlockKeyProto::MergeFrom(from.currentkey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExportedBlockKeysProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExportedBlockKeysProto::CopyFrom(const ExportedBlockKeysProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExportedBlockKeysProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_currentkey()) {
    if (!this->currentkey().IsInitialized()) return false;
  }
  for (int i = 0; i < allkeys_size(); i++) {
    if (!this->allkeys(i).IsInitialized()) return false;
  }
  return true;
}

void ExportedBlockKeysProto::Swap(ExportedBlockKeysProto* other) {
  if (other != this) {
    std::swap(isblocktokenenabled_, other->isblocktokenenabled_);
    std::swap(keyupdateinterval_, other->keyupdateinterval_);
    std::swap(tokenlifetime_, other->tokenlifetime_);
    std::swap(currentkey_, other->currentkey_);
    allkeys_.Swap(&other->allkeys_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExportedBlockKeysProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExportedBlockKeysProto_descriptor_;
  metadata.reflection = ExportedBlockKeysProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RecoveringBlockProto::kNewGenStampFieldNumber;
const int RecoveringBlockProto::kBlockFieldNumber;
#endif  // !_MSC_VER

RecoveringBlockProto::RecoveringBlockProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RecoveringBlockProto::InitAsDefaultInstance() {
  block_ = const_cast< ::hadoop::hdfs::LocatedBlockProto*>(&::hadoop::hdfs::LocatedBlockProto::default_instance());
}

RecoveringBlockProto::RecoveringBlockProto(const RecoveringBlockProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RecoveringBlockProto::SharedCtor() {
  _cached_size_ = 0;
  newgenstamp_ = GOOGLE_ULONGLONG(0);
  block_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RecoveringBlockProto::~RecoveringBlockProto() {
  SharedDtor();
}

void RecoveringBlockProto::SharedDtor() {
  if (this != default_instance_) {
    delete block_;
  }
}

void RecoveringBlockProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RecoveringBlockProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RecoveringBlockProto_descriptor_;
}

const RecoveringBlockProto& RecoveringBlockProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

RecoveringBlockProto* RecoveringBlockProto::default_instance_ = NULL;

RecoveringBlockProto* RecoveringBlockProto::New() const {
  return new RecoveringBlockProto;
}

void RecoveringBlockProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    newgenstamp_ = GOOGLE_ULONGLONG(0);
    if (has_block()) {
      if (block_ != NULL) block_->::hadoop::hdfs::LocatedBlockProto::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RecoveringBlockProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 newGenStamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &newgenstamp_)));
          set_has_newgenstamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_block;
        break;
      }

      // required .hadoop.hdfs.LocatedBlockProto block = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_block:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_block()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RecoveringBlockProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 newGenStamp = 1;
  if (has_newgenstamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->newgenstamp(), output);
  }

  // required .hadoop.hdfs.LocatedBlockProto block = 2;
  if (has_block()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->block(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RecoveringBlockProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 newGenStamp = 1;
  if (has_newgenstamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->newgenstamp(), target);
  }

  // required .hadoop.hdfs.LocatedBlockProto block = 2;
  if (has_block()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->block(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RecoveringBlockProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 newGenStamp = 1;
    if (has_newgenstamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->newgenstamp());
    }

    // required .hadoop.hdfs.LocatedBlockProto block = 2;
    if (has_block()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->block());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecoveringBlockProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RecoveringBlockProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RecoveringBlockProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RecoveringBlockProto::MergeFrom(const RecoveringBlockProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_newgenstamp()) {
      set_newgenstamp(from.newgenstamp());
    }
    if (from.has_block()) {
      mutable_block()->::hadoop::hdfs::LocatedBlockProto::MergeFrom(from.block());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RecoveringBlockProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RecoveringBlockProto::CopyFrom(const RecoveringBlockProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoveringBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_block()) {
    if (!this->block().IsInitialized()) return false;
  }
  return true;
}

void RecoveringBlockProto::Swap(RecoveringBlockProto* other) {
  if (other != this) {
    std::swap(newgenstamp_, other->newgenstamp_);
    std::swap(block_, other->block_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RecoveringBlockProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RecoveringBlockProto_descriptor_;
  metadata.reflection = RecoveringBlockProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

VersionRequestProto::VersionRequestProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VersionRequestProto::InitAsDefaultInstance() {
}

VersionRequestProto::VersionRequestProto(const VersionRequestProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VersionRequestProto::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionRequestProto::~VersionRequestProto() {
  SharedDtor();
}

void VersionRequestProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VersionRequestProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VersionRequestProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionRequestProto_descriptor_;
}

const VersionRequestProto& VersionRequestProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

VersionRequestProto* VersionRequestProto::default_instance_ = NULL;

VersionRequestProto* VersionRequestProto::New() const {
  return new VersionRequestProto;
}

void VersionRequestProto::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VersionRequestProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void VersionRequestProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VersionRequestProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VersionRequestProto::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionRequestProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VersionRequestProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VersionRequestProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VersionRequestProto::MergeFrom(const VersionRequestProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VersionRequestProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionRequestProto::CopyFrom(const VersionRequestProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionRequestProto::IsInitialized() const {

  return true;
}

void VersionRequestProto::Swap(VersionRequestProto* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VersionRequestProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VersionRequestProto_descriptor_;
  metadata.reflection = VersionRequestProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VersionResponseProto::kInfoFieldNumber;
#endif  // !_MSC_VER

VersionResponseProto::VersionResponseProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VersionResponseProto::InitAsDefaultInstance() {
  info_ = const_cast< ::hadoop::hdfs::NamespaceInfoProto*>(&::hadoop::hdfs::NamespaceInfoProto::default_instance());
}

VersionResponseProto::VersionResponseProto(const VersionResponseProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VersionResponseProto::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionResponseProto::~VersionResponseProto() {
  SharedDtor();
}

void VersionResponseProto::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void VersionResponseProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VersionResponseProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionResponseProto_descriptor_;
}

const VersionResponseProto& VersionResponseProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

VersionResponseProto* VersionResponseProto::default_instance_ = NULL;

VersionResponseProto* VersionResponseProto::New() const {
  return new VersionResponseProto;
}

void VersionResponseProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_info()) {
      if (info_ != NULL) info_->::hadoop::hdfs::NamespaceInfoProto::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VersionResponseProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hadoop.hdfs.NamespaceInfoProto info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VersionResponseProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .hadoop.hdfs.NamespaceInfoProto info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VersionResponseProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .hadoop.hdfs.NamespaceInfoProto info = 1;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VersionResponseProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .hadoop.hdfs.NamespaceInfoProto info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionResponseProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VersionResponseProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VersionResponseProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VersionResponseProto::MergeFrom(const VersionResponseProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::hadoop::hdfs::NamespaceInfoProto::MergeFrom(from.info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VersionResponseProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionResponseProto::CopyFrom(const VersionResponseProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionResponseProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void VersionResponseProto::Swap(VersionResponseProto* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VersionResponseProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VersionResponseProto_descriptor_;
  metadata.reflection = VersionResponseProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SnapshotInfoProto::kSnapshotNameFieldNumber;
const int SnapshotInfoProto::kSnapshotRootFieldNumber;
const int SnapshotInfoProto::kPermissionFieldNumber;
const int SnapshotInfoProto::kOwnerFieldNumber;
const int SnapshotInfoProto::kGroupFieldNumber;
const int SnapshotInfoProto::kCreateTimeFieldNumber;
#endif  // !_MSC_VER

SnapshotInfoProto::SnapshotInfoProto()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SnapshotInfoProto::InitAsDefaultInstance() {
  permission_ = const_cast< ::hadoop::hdfs::FsPermissionProto*>(&::hadoop::hdfs::FsPermissionProto::default_instance());
}

SnapshotInfoProto::SnapshotInfoProto(const SnapshotInfoProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SnapshotInfoProto::SharedCtor() {
  _cached_size_ = 0;
  snapshotname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  snapshotroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  permission_ = NULL;
  owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SnapshotInfoProto::~SnapshotInfoProto() {
  SharedDtor();
}

void SnapshotInfoProto::SharedDtor() {
  if (snapshotname_ != &::google::protobuf::internal::kEmptyString) {
    delete snapshotname_;
  }
  if (snapshotroot_ != &::google::protobuf::internal::kEmptyString) {
    delete snapshotroot_;
  }
  if (owner_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_;
  }
  if (group_ != &::google::protobuf::internal::kEmptyString) {
    delete group_;
  }
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    delete createtime_;
  }
  if (this != default_instance_) {
    delete permission_;
  }
}

void SnapshotInfoProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SnapshotInfoProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SnapshotInfoProto_descriptor_;
}

const SnapshotInfoProto& SnapshotInfoProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_hdfs_2eproto();
  return *default_instance_;
}

SnapshotInfoProto* SnapshotInfoProto::default_instance_ = NULL;

SnapshotInfoProto* SnapshotInfoProto::New() const {
  return new SnapshotInfoProto;
}

void SnapshotInfoProto::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_snapshotname()) {
      if (snapshotname_ != &::google::protobuf::internal::kEmptyString) {
        snapshotname_->clear();
      }
    }
    if (has_snapshotroot()) {
      if (snapshotroot_ != &::google::protobuf::internal::kEmptyString) {
        snapshotroot_->clear();
      }
    }
    if (has_permission()) {
      if (permission_ != NULL) permission_->::hadoop::hdfs::FsPermissionProto::Clear();
    }
    if (has_owner()) {
      if (owner_ != &::google::protobuf::internal::kEmptyString) {
        owner_->clear();
      }
    }
    if (has_group()) {
      if (group_ != &::google::protobuf::internal::kEmptyString) {
        group_->clear();
      }
    }
    if (has_createtime()) {
      if (createtime_ != &::google::protobuf::internal::kEmptyString) {
        createtime_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SnapshotInfoProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string snapshotName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_snapshotname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->snapshotname().data(), this->snapshotname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_snapshotRoot;
        break;
      }

      // required string snapshotRoot = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_snapshotRoot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_snapshotroot()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->snapshotroot().data(), this->snapshotroot().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_permission;
        break;
      }

      // required .hadoop.hdfs.FsPermissionProto permission = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_permission:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_permission()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_owner;
        break;
      }

      // required string owner = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_owner:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_owner()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->owner().data(), this->owner().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_group;
        break;
      }

      // required string group = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->group().data(), this->group().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_createTime;
        break;
      }

      // required string createTime = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_createTime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_createtime()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->createtime().data(), this->createtime().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SnapshotInfoProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string snapshotName = 1;
  if (has_snapshotname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->snapshotname().data(), this->snapshotname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->snapshotname(), output);
  }

  // required string snapshotRoot = 2;
  if (has_snapshotroot()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->snapshotroot().data(), this->snapshotroot().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->snapshotroot(), output);
  }

  // required .hadoop.hdfs.FsPermissionProto permission = 3;
  if (has_permission()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->permission(), output);
  }

  // required string owner = 4;
  if (has_owner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->owner().data(), this->owner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->owner(), output);
  }

  // required string group = 5;
  if (has_group()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->group().data(), this->group().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->group(), output);
  }

  // required string createTime = 6;
  if (has_createtime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->createtime().data(), this->createtime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->createtime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SnapshotInfoProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string snapshotName = 1;
  if (has_snapshotname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->snapshotname().data(), this->snapshotname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->snapshotname(), target);
  }

  // required string snapshotRoot = 2;
  if (has_snapshotroot()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->snapshotroot().data(), this->snapshotroot().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->snapshotroot(), target);
  }

  // required .hadoop.hdfs.FsPermissionProto permission = 3;
  if (has_permission()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->permission(), target);
  }

  // required string owner = 4;
  if (has_owner()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->owner().data(), this->owner().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->owner(), target);
  }

  // required string group = 5;
  if (has_group()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->group().data(), this->group().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->group(), target);
  }

  // required string createTime = 6;
  if (has_createtime()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->createtime().data(), this->createtime().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->createtime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SnapshotInfoProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string snapshotName = 1;
    if (has_snapshotname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->snapshotname());
    }

    // required string snapshotRoot = 2;
    if (has_snapshotroot()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->snapshotroot());
    }

    // required .hadoop.hdfs.FsPermissionProto permission = 3;
    if (has_permission()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->permission());
    }

    // required string owner = 4;
    if (has_owner()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->owner());
    }

    // required string group = 5;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group());
    }

    // required string createTime = 6;
    if (has_createtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->createtime());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SnapshotInfoProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SnapshotInfoProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SnapshotInfoProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SnapshotInfoProto::MergeFrom(const SnapshotInfoProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_snapshotname()) {
      set_snapshotname(from.snapshotname());
    }
    if (from.has_snapshotroot()) {
      set_snapshotroot(from.snapshotroot());
    }
    if (from.has_permission()) {
      mutable_permission()->::hadoop::hdfs::FsPermissionProto::MergeFrom(from.permission());
    }
    if (from.has_owner()) {
      set_owner(from.owner());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_createtime()) {
      set_createtime(from.createtime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SnapshotInfoProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshotInfoProto::CopyFrom(const SnapshotInfoProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  if (has_permission()) {
    if (!this->permission().IsInitialized()) return false;
  }
  return true;
}

void SnapshotInfoProto::Swap(SnapshotInfoProto* other) {
  if (other != this) {
    std::swap(snapshotname_, other->snapshotname_);
    std::swap(snapshotroot_, other->snapshotroot_);
    std::swap(permission_, other->permission_);
    std::swap(owner_, other->owner_);
    std::swap(group_, other->group_);
    std::swap(createtime_, other->createtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SnapshotInfoProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SnapshotInfoProto_descriptor_;
  metadata.reflection = SnapshotInfoProto_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdfs
}  // namespace hadoop

// @@protoc_insertion_point(global_scope)
